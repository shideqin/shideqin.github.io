<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Composer 使用记录</title>
    <url>/posts/635.html</url>
    <content><![CDATA[<p>Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。</p>
<p>运行 Composer 需要 PHP 5.3.2+ 以上版本。一些敏感的 PHP 设置和编译标志也是必须的，但对于任何不兼容项安装程序都会抛出警告。</p>
<p><strong>全局安装</strong> <strong>（推荐）</strong></p>
<p><code>curl -sS https://getcomposer.org/installer | php</code></p>
<p><code>mv composer.phar /usr/local/bin/composer</code></p>
<p>局部安装</p>
<p><code>curl -sS https://getcomposer.org/installer | php</code></p>
<p><strong>全局配置（推荐）</strong></p>
<p>阿里 Composer 全量镜像</p>
<p><code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></p>
<p>取消配置</p>
<p><code>composer config -g --unset repos.packagist</code></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell6 &amp; Xftp6 和谐大法</title>
    <url>/posts/602.html</url>
    <content><![CDATA[<p>Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。<br>　　Xftp是一种灵活且轻量级的SFTP/FTP客户端，用于需要安全地通过网络传输文件的用户。文件传输被简化，使用拖拽、直接编辑和增强的同步，这些特性在直观的标签界面中被封装。</p>
<h4 id="Xshell-amp-Xftp-显示评估期已过，怎么解决？"><a href="#Xshell-amp-Xftp-显示评估期已过，怎么解决？" class="headerlink" title="Xshell &amp; Xftp 显示评估期已过，怎么解决？"></a>Xshell &amp; Xftp 显示评估期已过，怎么解决？</h4><p><strong>一、 卸载所有版本的Xshell，Xmanager，Xftp，Xldp和Netsarang产品</strong>，并从注册表中删除 NetSarang 目录 (HKEY_CURRENT_USER\Software\NetSarang)。</p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-c7b4ea247f6f3968-1024x645-1.jpg" alt=""></p>
<p><strong>二、下载 Xshell 6 &amp; Xftp 6</strong></p>
<p>下载方式</p>
<blockquote>
<p>在 <a href="http://www.netsarang.com/download/main.html" target="_blank" rel="noopener">http://www.netsarang.com/download/main.html</a> 选择下载评估版，收到下载地址后将下载地址加上r。<br>例如 <a href="https://cdn.netsarang.net/f8a8d224/XmanagerPowerSuite-6.0.0009.exe" target="_blank" rel="noopener">https://cdn.netsarang.net/f8a8d224/XmanagerPowerSuite-6.0.0009.exe</a> ，<br>改为 <a href="https://cdn.netsarang.net/f8a8d224/XmanagerPowerSuite-6.0.0009r.exe" target="_blank" rel="noopener">https://cdn.netsarang.net/f8a8d224/XmanagerPowerSuite-6.0.0009r.exe</a> 。<br>如果下载不带r的版本，无法输入序列号，注意不要下载到“思杰马克丁”特供版，下载完毕后，对安装包右键，属性，数字签名，如果是官方版则是“NetSarang Computer, Inc.”。</p>
</blockquote>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/20191227085840.png" alt=""></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-a9351873fd98543a-1024x1014-1.jpg" alt=""></p>
<p><strong>三、 添加路由到 C:\Windows\System32\drivers\etc\hosts</strong></p>
<blockquote>
<p>127.0.0.1 transact.netsarang.com<br>127.0.0.1 update.netsarang.com<br>127.0.0.1 <a href="http://www.netsarang.com" target="_blank" rel="noopener">www.netsarang.com</a><br>127.0.0.1 <a href="http://www.netsarang.co.kr" target="_blank" rel="noopener">www.netsarang.co.kr</a><br>127.0.0.1 sales.netsarang.com</p>
</blockquote>
<p><strong>四、一定要在前三步骤做完之后再安装带r版本的 Xshell6 &amp; Xftp6</strong></p>
<blockquote>
<p>注册码<br>Xshell Plus 6 : 180505-117501-020791<br>Xmanager Power Suite 6 :180429-116253-999126</p>
</blockquote>
<p><strong>五、安装完成后，将对应的程序运行一次后，打开注册表，将下列字段设置为当前用户拒绝全部权限，否则会反弹</strong></p>
<blockquote>
<p>HKEY_CURRENT_USER\Software\NetSarang\Xftp\6\LiveUpdate<br>HKEY_CURRENT_USER\Software\NetSarang\Xlpd\6\LiveUpdate<br>HKEY_CURRENT_USER\Software\NetSarang\Xmanager\6\LiveUpdate<br>HKEY_CURRENT_USER\Software\NetSarang\Xshell\6\LiveUpdate</p>
</blockquote>
<p><strong>打开注册表程序（开始 -&gt; 运行 -&gt; regedit 或 win + R 打开运行输入 regedit 回车进入注册表编辑器）</strong></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-6a0ab99e9fc7aadd-1024x912-1.jpg" alt=""></p>
<p><strong>点击 “高级”</strong></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-ac71a019b4cf2ded-1024x874-1.jpg" alt=""></p>
<p><strong>禁用继承</strong></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-c3496cbe0ebbb745-1024x729-1.jpg" alt=""></p>
<p><strong>权限转换</strong></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-e3db2968581322d3-1024x874-1.jpg" alt=""></p>
<p><strong>编辑并取消各用户的所有权限</strong></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-dceed98e752920b2-1024x750-1.jpg" alt=""></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-0ea7149d506ac2dd-1024x674-1.jpg" alt=""></p>
<p><strong>已注册的Xshell6</strong></p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-9a9919fa6d3464a2-1024x716-1.jpg" alt=""></p>
<p>Xftp同样按照以上步骤操作，把权限去掉即可。</p>
<p><strong>六、彻底禁用 Xshell &amp; Xftp 更新</strong></p>
<p>xshell菜单—-工具—选项<br>在选项设置里面，点击更新选项卡，去掉实时更新的勾选</p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-254056398bdbc76d-1024x371-1.jpg" alt=""></p>
<p>删除更新程序</p>
<p><img src="http://www.phpkoo.com/wp-content/uploads/2019/12/1926763-4f42e18be6398dc7-1024x733-1.jpg" alt=""></p>
<p>也可以把 LiveUpdate.exe 换成别的一个空文件来替换</p>
<blockquote>
<p>注册码可以用这个生成<br><a href="https://github.com/DoubleLabyrinth/Xmanager-keygen" target="_blank" rel="noopener">https://github.com/DoubleLabyrinth/Xmanager-keygen</a><br>需要用Python3.6 执行</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样增大 Linux 系统的 open file(s) 上限</title>
    <url>/posts/596.html</url>
    <content><![CDATA[<p>最近在工作中遇到一个问题，尝试直接将服务运行在高配（40core, 192GB；相比虚拟机来说） 的物理机上，但是发现服务打开的文件句柄达到 80 万左右就不能再开更多了。</p>
<p>80 万已经是一个不小的值了，通常情况下，Linux 默认的值都很小，例如：Debian 8(jessie) 给普通用户设置的 open file(s) 限制为 65536， 可以通过下面的命令查看当前限制。</p>
<p>$ ulimit -n<br>$ ulimit -Sn<br>$ ulimit -Hn</p>
<p><code>ulimit</code> 是一个 shell（这里使用的是 bash） 内置命令，可以通过 <code>type ulimit</code> 验证。</p>
<p><code>-n</code> 即表示查看或者设置 open file(s) 的限制，在 ulimit 中，每个限制都有两种类型：</p>
<ul>
<li><code>-S</code>, soft limit, 软限制，用户可以上调软限制到硬限制</li>
<li><code>-H</code>, hard limit, 硬限制，非 root 用户不能修改</li>
</ul>
<p>如果没有指明，则同时修改软限制和硬限制。</p>
<h2 id="修改-ulimit"><a href="#修改-ulimit" class="headerlink" title="修改 ulimit"></a>修改 ulimit</h2><p>修改分为临时修改和永久修改，临时修改只对当前 session 有效，登出和重启后都恢复系统设置。</p>
<p>临时修改使用 <code>ulimit</code> 命令，以修改 open file(s) 为例。</p>
<p># ulimit -n 1024000<br># ulimit -n<br>1024000</p>
<p>永久修改需要修改 <code>/etc/security/limits.conf</code> 或者在 <code>/etc/security/limits.d/</code> 目录下添加一个文件。具体格式参考 <code>/etc/security/limits.conf</code>，里面有详细说明。</p>
<h2 id="open-file-s-上限"><a href="#open-file-s-上限" class="headerlink" title="open file(s) 上限"></a>open file(s) 上限</h2><p>回到遇到的问题中来：服务打开 80 万个左右的文件句柄就不能再打开了。所以， 尝试将 ulimit 设置为 1000 万，结果提示出错：</p>
<p># ulimit -n 10000000<br>-bash: ulimit: open files: cannot modify limit: Operation not permitted</p>
<p>注意，使用的可以 root 用户，居然没有权限，然后尝试降低到：</p>
<ul>
<li>500 万，依然错误</li>
<li>300 万，依然错误</li>
<li>200 万，依然错误</li>
<li>100 万，成功了</li>
</ul>
<p>显然，这里有一个上限，大概在 100-200 万之间。</p>
<p>所以，解决问题的办法，在于怎样提高这个上限！</p>
<p>通过一番搜索，发现 open file(s) kernel 级别有 2 个配置，分别是：</p>
<p>fs.nr_open，进程级别<br>fs.file-max，系统级别</p>
<p><code>fs.nr_open</code> 默认设置的上限是 1048576，所以用户的 open file(s) 不可能超过这个上限。</p>
<p># sysctl -w fs.nr_open=10000000<br># ulimit -n 10000000<br># ulimit -n<br>10000000</p>
<p>修改后即可设置更大的 open file(s) 了。</p>
<p>同样，对于 kernel 参数的修改，<code>sysctl</code> 命令修改的是当前运行时，如果需要永久修改， 则将配置添加到 <code>/etc/sysctl.conf</code> 中，例如：</p>
<p># echo “fs.nr_open = 10000000” &gt;&gt; /etc/sysctl.conf<br># echo “fs.file-max = 11000000” &gt;&gt; /etc/sysctl.conf</p>
<p>注意：<code>fs.nr_open</code> 总是应该小于等于 <code>fs.file-max</code>。</p>
<p>如果要查看当前打开的文件数，使用下面的命令：</p>
<p># sysctl fs.file-nr<br>fs.file-nr = 1760       0       11000000</p>
<p>不过，增大这些值意味着能够打开更多的文件（在 Linux 中，everything is file，包括 socket），但是同时也意味着消耗更多的资源，所以基本上在物理机上才会遇到这种问题。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ulimit</tag>
      </tags>
  </entry>
  <entry>
    <title>golang mod使用私有仓库相关事项</title>
    <url>/posts/580.html</url>
    <content><![CDATA[<p>一、Go get命令出现terminal prompts disabled解决</p>
<p>原因go get disable “terminal prompt” by default（Go get 命令默认禁用terminal prompt，即终端提示）</p>
<p>解决方案</p>
<p>设置环境变量：<code>GIT_TERMINAL_PROMPT=1</code>， 可以把上面的命令写到 <code>.bashrc</code> 或 <code>.bash_profile</code> 文件当中。</p>
<p>二、一键解决 go get golang.org/x 包失败</p>
<p>当我们使用 <code>go get</code>、<code>go install</code>、<code>go mod</code> 等命令时，会自动下载相应的包或依赖包。但由于众所周知的原因，类似于 <code>golang.org/x/...</code> 的包会出现下载失败的情况。如下所示：</p>
<p>$ go get -u golang.org/x/sys  </p>
<p>go get golang.org/x/sys: unrecognized import path “golang.org/x/sys” (https fetch: Get <a href="https://golang.org/x/sys?go-get=1" target="_blank" rel="noopener">https://golang.org/x/sys?go-get=1</a>: dial tcp 216.239.37.1:443: i/o timeout)</p>
<p>我们可以通过设置GOPROXY 环境变量来解决，我们知道从 <code>Go 1.11</code> 版本开始，官方支持了 <code>go module</code> 包依赖管理工具。其实还新增了 <code>GOPROXY</code> 环境变量。</p>
<p>解决方案</p>
<p>设置环境变量：<code>GOPROXY=https://goproxy.io</code>， 可以把上面的命令写到 <code>.bashrc</code> 或 <code>.bash_profile</code> 文件当中。</p>
<p>三、总结</p>
<p>解决 terminal prompts disabled</p>
<p><code>export GIT_TERMINAL_PROMPT=1</code></p>
<p>解决 go get golang.org/x 包失败</p>
<p><code>export GOPROXY=https://goproxy.io</code></p>
<p>启用 Go Modules 功能</p>
<p><code>export GO111MODULE=on</code></p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>mod</tag>
      </tags>
  </entry>
  <entry>
    <title>git报错 SSL connect error</title>
    <url>/posts/564.html</url>
    <content><![CDATA[<p>报错信息：  </p>
<p>fatal: unable to access ‘<a href="https://github.com/***/***&#39;" target="_blank" rel="noopener">https://github.com/***/***&#39;</a>: SSL connect error</p>
<p>解决办法：</p>
<p><code>git config --global http.sslversion tlsv1</code></p>
<p>或者</p>
<p><code>git config --global http.sslVerify false</code>           //设置跳过SSL证书验证</p>
<p>如果还不行，可能是ssh版本过低需要升级ssh。执行命令：</p>
<p><code>yum update nss</code>                    //redhat  centos</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>centos下php7安装gmagick扩展</title>
    <url>/posts/511.html</url>
    <content><![CDATA[<p>GraphicsMagick 是 ImageMagick 的另一个分支功能和 ImageMagick 类似。下面我们介绍一下在PHP7下如何安装扩展。</p>
<p>一、安装 GraphicsMagick 依赖</p>
<p>yum install GraphicsMagick-devel</p>
<p>二、选择手动方式安装gmagick（php扩展）<br>我们这里选择最新稳定版（gmagick-2.0.5RC1）</p>
<p>wget <a href="https://pecl.php.net/get/gmagick-2.0.5RC1.tgz" target="_blank" rel="noopener">https://pecl.php.net/get/gmagick-2.0.5RC1.tgz</a><br>tar -zxvf gmagick-2.0.5RC1.tgz<br>cd gmagick-2.0.5RC1<br>/usr/local/php/bin/phpize<br>./configure –with-php-config=/usr/local/php/bin/php-config<br>make &amp;&amp; make install</p>
<p>三、选择pecl方式安装gmagick（php扩展）</p>
<p>pecl install gmagick</p>
<p>四、修改php.ini 增加 extension，同时reload php-fpm 完成。</p>
<p>ps：<br>安装过程中可能出现以下问题<br>linux ‘….’:is not a valid libtool object”错误<br>解决方法</p>
<p>make clean</p>
<p>然后在重新执行命令，原因是编译的时候有问题重新编译一下文件就解决了</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>GMAGICK</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下yum安装libmcrypt错误：No package libmcrypt available</title>
    <url>/posts/507.html</url>
    <content><![CDATA[<p>错误描述：</p>
<p>yum install libmcrypt libmcrypt-devel</p>
<p>Setting up Install Process<br>No package libmcrypt available.<br>No package libmcrypt-devel available.<br>Error: Nothing to do</p>
<p>我们会看到centos yum从仓库中根本找不到这几个包。但我不想使用源码编译就想使用yum安装，怎么办？ 解决方法：</p>
<p>yum install epel-release  //扩展包更新包<br>yum update //更新yum源</p>
<p>然后再重新</p>
<p>yum install libmcrypt libmcrypt-devel</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore 不起作用的解决办法</title>
    <url>/posts/504.html</url>
    <content><![CDATA[<p>把某些目录或文件加入.gitignore规则，发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：</p>
<p>git rm -r –cached .<br>git add .<br>git commit -m ‘update .gitignore’</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 7 下安装openvpn</title>
    <url>/posts/490.html</url>
    <content><![CDATA[<p>一、环境版本 1、CentOS 7.4 2、OpenVPN 2.4.6 3、easy-rsa 3.0 二、安装</p>
<p>yum install epel-release<br>yum install -y openssl openssl-devel lzo lzo-devel pam pam-devel automake pkgconfig makecache<br>yum install -y openvpn<br>yum install -y easy-rsa</p>
<p>三、添加openvpn配置用户</p>
<p>#启动openvpn的用户<br>groupadd openvpn<br>useradd -g openvpn -M -s /sbin/nologin openvpn </p>
<p>四、创建配置文件</p>
<p>mkdir /etc/openvpn/<br>cp -r /usr/share/easy-rsa/ /etc/openvpn/<br>cp -r /usr/share/doc/easy-rsa-3.0.3/vars.example /etc/openvpn/easy-rsa/3.0/vars<br>cp -r /usr/share/doc/openvpn-2.4.6/sample/sample-config-files/server.conf /etc/openvpn/server.conf</p>
<p>五、修改easy-rsa密钥生成配置（修改第45、65、76、84-89、97、105、113、117、134、139、171、180、192行）</p>
<p>vim /etc/openvpn/easy-rsa/3.0/vars</p>
<p>set_var EASYRSA “$PWD”<br>set_var EASYRSA_PKI “$EASYRSA/pki”<br>set_var EASYRSA_DN “cn_only”<br>set_var EASYRSA_REQ_COUNTRY “CN”<br>set_var EASYRSA_REQ_PROVINCE “BEIJING”<br>set_var EASYRSA_REQ_CITY “BEIJING”<br>set_var EASYRSA_REQ_ORG “OpenVPN CERTIFICATE AUTHORITY”<br>set_var EASYRSA_REQ_EMAIL “<a href="mailto:110@qq.com">110@qq.com</a>“<br>set_var EASYRSA_REQ_OU “OpenVPN EASY CA”<br>set_var EASYRSA_KEY_SIZE 2048<br>set_var EASYRSA_ALGO rsa<br>set_var EASYRSA_CA_EXPIRE 7000<br>set_var EASYRSA_CERT_EXPIRE 3650<br>set_var EASYRSA_NS_SUPPORT “no”<br>set_var EASYRSA_NS_COMMENT “OpenVPN CERTIFICATE AUTHORITY”<br>set_var EASYRSA_EXT_DIR “$EASYRSA/x509-types”<br>set_var EASYRSA_SSL_CONF “$EASYRSA/openssl-1.0.cnf”<br>set_var EASYRSA_DIGEST “sha256”</p>
<p>六、生成ca证书</p>
<p>cd /etc/openvpn/easy-rsa/3.0<br>./easyrsa init-pki<br>./easyrsa build-ca<br>#设置ca密码（输入两次）：</p>
<p>#生成Diffie Hellman key exchange文件<br>./easyrsa gen-dh</p>
<p>#生成tls-auth key文件<br>cd /etc/openvpn<br>openvpn –genkey –secret ta.key</p>
<p>#使用gen-req来生成req<br>cd /etc/openvpn/easy-rsa/3.0<br>./easyrsa  gen-req wwwserver</p>
<p>#签发服务端证书<br>./easyrsa sign-req server wwwserver</p>
<p>#生成客户端用户<br>./easyrsa build-client-full www001</p>
<p>七、修改openvpn服务端配置</p>
<p>vim /etc/openvpn/server.conf</p>
<p>port 1194<br>proto udp<br>dev tun<br>ca /etc/openvpn/easy-rsa/3.0/pki/ca.crt<br>cert /etc/openvpn/easy-rsa/3.0/pki/issued/wwwserver.crt<br>key /etc/openvpn/easy-rsa/3.0/pki/private/wwwserver.key<br>dh /etc/openvpn/easy-rsa/3.0.3/pki/dh.pem<br>tls-auth /etc/openvpn/ta.key 0<br>server 10.8.0.0 255.255.255.0<br>ifconfig-pool-persist ipp.txt<br>push “redirect-gateway def1 bypass-dhcp”<br>push “dhcp-option DNS 223.5.5.5”<br>push “dhcp-option DNS 114.114.114.114”<br>keepalive 10 120<br>cipher AES-256-CBC<br>comp-lzo<br>max-clients 50<br>user openvpn<br>group openvpn<br>persist-key<br>persist-tun<br>status openvpn-status.log<br>log-append openvpn.log<br>verb 3<br>mute 20</p>
<p>八、服务器防火墙和路由配置</p>
<p>在iptables中添加一条路由转发规则, 并保存:<br>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE<br>iptables-save</p>
<p>同时, 我们必须在sysctl中启用ip forward.<br>打开文件vi /etc/sysctl.conf, 并添加以下内容:<br>net.ipv4.ip_forward = 1<br>然后重启网络:<br>systemctl restart network.service</p>
<p>九、启动服务器</p>
<p>systemctl start openvpn@server<br>#启动时输入服务端证书密码：</p>
<p>十、客户端配置（下载客户端证书）</p>
<p>mkdir -p /etc/openvpn/client<br>cp -r /etc/openvpn/easy-rsa/3.0/pki/issued/www001.crt /etc/openvpn/client/<br>cp -r /etc/openvpn/easy-rsa/3.0/pki/private/www001.key /etc/openvpn/client/<br>cp -r /etc/openvpn/easy-rsa/3.0/pki/ca.crt /etc/openvpn/client/<br>cp -r /etc/openvpn/ta.key /etc/openvpn/client/ </p>
<p>十一、修改客户端ovpn文件</p>
<p>client<br>dev tun<br>proto udp<br>remote xxx.xxx.xxx.xxx 1194 #改成外网IP<br>resolv-retry infinite<br>nobind<br>persist-key<br>persist-tun<br>comp-lzo<br>ca ca.crt<br>cert www001.crt<br>key www001.key<br>remote-cert-tls server<br>tls-auth ta.key 1<br>cipher AES-256-CBC<br>keepalive 10 120<br>verb 5</p>
<p>ps 1、如果是阿里云的专用网络，需要配置放行1194端口udp 2、如生成证书时输错密码（删除以下文件即可）</p>
<p>rm -rf /etc/openvpn/easy-rsa/3.0/pki/reqs/www001.req<br>rm -rf /etc/openvpn/easy-rsa/3.0/pki/private/www001.key</p>
<p>3、撤销证书</p>
<p>cd /etc/openvpn/easy-rsa/3.0<br>./easyrsa revoke www001</p>
<p>4、解决服务器每次都要输入Enter PEM pass phrase</p>
<p>openssl rsa -in server.key -out server.key.unsecure</p>
<p>服务器改用这个server.key.unsecure就不会每次提示了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>openvpn</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下php7安装imagick扩展</title>
    <url>/posts/477.html</url>
    <content><![CDATA[<p>ImageMagick是一个用于查看、编辑位图文件以及进行图像格式转换的开放源代码软件套装。ImageMagick官方提供了多种开发语言的扩展或者类库。下面我们介绍一下在PHP7下如何安装扩展。 一、安装ImageMagick依赖</p>
<p>yum install ImageMagick-devel</p>
<p>二、选择手动方式安装imagick（php扩展） 我们这里选择最新稳定版（imagick-3.4.0）</p>
<p>wget <a href="https://pecl.php.net/get/imagick-3.4.0.tgz" target="_blank" rel="noopener">https://pecl.php.net/get/imagick-3.4.0.tgz</a><br>tar -zxvf imagick-3.4.0.tgz<br>cd imagick-3.4.0<br>/usr/local/php/bin/phpize<br>./configure –with-php-config=/usr/local/php/bin/php-config<br>make &amp;&amp; make install</p>
<p>三、选择pecl方式安装imagick（php扩展）</p>
<p>pecl install imagick</p>
<p>四、修改php.ini 增加 extension，同时reload php-fpm 完成。 ps： 安装过程中可能出现以下问题 linux ‘….’:is not a valid libtool object”错误 解决方法</p>
<p>make clean</p>
<p>然后在重新执行命令，原因是编译的时候有问题重新编译一下文件就解决了</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>imagick</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 安装 Docker CE</title>
    <url>/posts/468.html</url>
    <content><![CDATA[<p><strong>准备工作</strong> <strong>一、系统要求</strong> Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。 <strong>二、卸载旧版本</strong> 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<p>yum remove docker <br>           docker-client <br>           docker-client-latest <br>           docker-common <br>           docker-latest <br>           docker-latest-logrotate <br>           docker-logrotate <br>           docker-selinux <br>           docker-engine-selinux <br>           docker-engine</p>
<p><strong>三、使用 yum 安装</strong> 执行以下命令安装依赖包：</p>
<p>yum install -y yum-utils <br>           device-mapper-persistent-data <br>           lvm2</p>
<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 执行下面的命令添加 yum 软件源：</p>
<p>yum-config-manager <br>    –add-repo <br>    <a href="https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</a></p>
<p># 官方源<br># $ sudo yum-config-manager <br>#     –add-repo <br>#     <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a></p>
<p>如果需要最新版本的 Docker CE 请使用以下命令：</p>
<p>yum-config-manager –enable docker-ce-edge</p>
<p>如果需要测试版本的 Docker CE 请使用以下命令：</p>
<p>yum-config-manager –enable docker-ce-test</p>
<p><strong>安装 Docker CE</strong> 更新 yum 软件源缓存，并安装 docker-ce。</p>
<p>yum makecache fast<br>yum install docker-ce</p>
<p>或者 <strong>使用脚本自动安装</strong> 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：</p>
<p>curl -fsSL get.docker.com -o get-docker.sh<br>sh get-docker.sh –mirror Aliyun</p>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。 <strong>启动 Docker CE</strong></p>
<p>systemctl enable docker<br>systemctl start docker</p>
<p><strong>建立 docker 用户组（如果使用root用户操作 可忽略）</strong> 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组：</p>
<p>groupadd docker</p>
<p>将当前用户加入 docker 组：</p>
<p>usermod -aG docker $USER</p>
<p>退出当前终端并重新登录，进行如下测试。 <strong>测试 Docker 是否安装正确</strong></p>
<p>docker version</p>
<p><strong>添加内核参数</strong> 默认配置下，如果在 CentOS 使用 Docker CE 看到下面的这些警告信息：</p>
<p>WARNING: bridge-nf-call-iptables is disabled<br>WARNING: bridge-nf-call-ip6tables is disabled</p>
<p>请添加内核配置参数以启用这些功能。</p>
<p>tee -a /etc/sysctl.conf &lt;&lt;-EOF<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>EOF</p>
<p>然后重新加载 sysctl.conf 即可</p>
<p>sysctl -p</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos7</tag>
        <tag>docker-ce</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS中证书链不完整的解决方案</title>
    <url>/posts/458.html</url>
    <content><![CDATA[<p>由于我们的部分业务场景是在微信（WebView）中打开https的web页面，在测试过程中却发现了一个问题，在Chrome中测试完全正常的https页面，在iOS的微信（WebView）中表现正常，但在Android中，不论是哪个版本的安卓系统，都不能正常打开页面，要么就是一片白，要么就是直接无法打开，解决这个问题，需要在服务器上配置完整的SSL证书链。 之后在Android自带的浏览器中测试，几乎所有的手机都出现下面这样的情况 <a href="http://www.phpkoo.com/wp-content/uploads/2018/06/httpsCertificateChain1.png" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2018/06/httpsCertificateChain1.png" alt=""></a> <a href="http://www.phpkoo.com/wp-content/uploads/2018/06/httpsCertificateChain2.png" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2018/06/httpsCertificateChain2.png" alt=""></a> <a href="http://www.phpkoo.com/wp-content/uploads/2018/06/httpsCertificateChain3.png" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2018/06/httpsCertificateChain3.png" alt=""></a> <strong>证书链</strong> 看来Andorid的WebView不能打开页面应该是与这有关，造成这个问题的主要原因是我们服务器配置证书的证书链不全造成的。 证书链其实就是描述证书的签名环节，就比如是 A 颁发证书给 B ，B颁发证书给C，然后我们手里的就是证书C。当证书链不完整的情况下，也就是没有描述我们手中的证书C是由谁办法的，所以导致的浏览器不认为你这个证书是可信的授权证书。 每个设备中都会存有一些默认的可信的根证书，但很多CA是不使用根证书进行签名的，而是使用中间层证书进行签名，因为这样做能更快的进行替换（这句可能不对，原文是 because these can be rotated more frequently）。 如果你的服务器上没有中间件证书，这样的结果就是你的服务器上只有你的网站的证书，客户端的浏览器里只有CA的根证书，这样就会导致证书信任链不全，才导致了上面那两个截图中的问题。这种中间层证书不全的问题多出现在移动端的浏览器上（就我目前看，iOS8 iOS9 都没有出现问题，Andorid各个版本都有这个问题）。 当你服务器上的证书中的信任链不全的情况下，浏览器会认为当前的链接是一个不安全的，会阻止页面的打开。 <strong>解决方案</strong> 说清楚了原因，解决问题就很简单了，只要把我们的证书链补全就可以了。 从SSL证书服务商那里，你获得的crt证书文件大概是这个样子的：</p>
<p>—–BEGIN CERTIFICATE—–<br>    # 证书内容<br>—–END CERTIFICATE—–</p>
<p>在你补全中间层证书和根证书后，新的crt证书文件看起来是这样的：</p>
<p>—–BEGIN CERTIFICATE—–<br>    # 证书内容 1<br>—–END CERTIFICATE—–</p>
<p>—–BEGIN CERTIFICATE—–<br>    # 证书内容 2<br>—–END CERTIFICATE—–</p>
<p>—–BEGIN CERTIFICATE—–<br>    # 证书内容 3<br>—–END CERTIFICATE—–</p>
<p>这里包含了你的证书，以及从你的证书向上递归直至根证书的全部证书，这样就可以向浏览器证明你的链接是安全的。 <strong>补全证书链</strong> 比较方便的是使用这个在线的工具： <a href="https://certificatechain.io" target="_blank" rel="noopener">https://certificatechain.io</a> 进入这个网站，粘贴进你的证书（只包含你的用户证书），或者上传你的证书，他就会给出补全后的证书文件，你只需要粘贴回你的文件或者下载覆盖就可以了，然后在服务器上重新部署就可以解决问题。 由于这里只需要上传证书，所以是安全的，不需要担心不安全的问题。 如果不喜欢用在线的工具，可以使用下面这个本地的工具，PHP写的，在命令行中运行： <a href="https://github.com/spatie/ssl-certificate-chain-resolver" target="_blank" rel="noopener">Github ssl-certificate-chain-resolver</a> <strong>PS:</strong> 一般情况下 cert.pem 是证书 chain.pem 是证书链编码 fullchain.pem 是cert.pem和chain.pem的证书集合 privkey.pem 是私钥文件</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>证书链</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL: libmysqlclient.so.20: cannot open shared object file解决方法</title>
    <url>/posts/454.html</url>
    <content><![CDATA[<p>import MySQLdb的时候报错“ImportError: libmysqlclient.so.20: cannot open shared object file: No such file or directory” 解决方法： 找到libmysqlclient.so.20,一般都在mysql安装目录/lib库里，做个软链接即可。</p>
<p>#64为系统<br>ln -s /usr/local/mysql/lib/libmysqlclient.so.20 /usr/lib64/libmysqlclient.so.20</p>
<p>#32位系统<br>ln -s /usr/local/mysql/lib/libmysqlclient.so.20 /usr/lib/libmysqlclient.so.20</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>libmysqlclient</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置ssl及优化</title>
    <url>/posts/425.html</url>
    <content><![CDATA[<p>https是一种超文本传输安全协议，主要是用SSL/TLS来加密数据包，以达到数据加密传输的作用，同时也能一定程度达到防劫持的效果。 <strong>隐藏不必要的信息</strong> 细心的朋友会发现，请求响应头，有这么一行 server: nginx，说明我用的是 Nginx 服务器，但并没有具体的版本号。由于某些 Nginx 漏洞只存在于特定的版本，隐藏版本号可以提高安全性。这只需要在配置里加上这个就可以了：</p>
<p>server_tokens  off;</p>
<p>另外，一些 WEB 语言或框架默认输出的 x-powered-by 也会泄露网站信息，他们一般都提供了修改或移除的方法，可以自行查看手册。如果部署上用到了 Nginx 的反向代理，也可以通过 proxy_hide_header 指令隐藏它：</p>
<p>proxy_hide_header  X-Powered-By;</p>
<p><strong>禁用非必要的方法</strong> 一般情况下，只需要处理 GET、POST 两种请求方法，而 HTTP/1 协议还规定了 TRACE 这样的方法用于网络诊断，这也可能会暴露一些信息。所以我针对 GET、POST 以及 HEAD 之外的请求，直接返回了 444 状态码（444 是 Nginx 定义的响应状态码，会立即断开连接，没有响应正文）。具体配置是这样的：</p>
<p>if ($request_method !~ ^(GET|HEAD|POST)$ ) {<br>    return    444;<br>}</p>
<p><strong>合理配置响应头</strong></p>
<p>#减少点击劫持<br>add_header X-Frame-Options DENY;</p>
<p>#禁止服务器自动解析资源类型<br>add_header X-Content-Type-Options nosniff;</p>
<p>#防XSS攻击<br>add_header X-XSS-Protection “1; mode=block”;</p>
<p>#HSTS策略<br>add_header Strict-Transport-Security “max-age=31536000; includeSubDomains; preload” always;</p>
<p><code>X-Frame-Options</code> 用来指定此网页是否允许被 iframe 嵌套，deny 就是不允许任何嵌套发生。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="noopener">这部分内容更多信息</a>。 <code>X-Content-Type-Options</code> 用来指定浏览器对未指定或错误指定 Content-Type 资源真正类型的猜测行为，nosniff 表示不允许任何猜测。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options" target="_blank" rel="noopener">这部分内容更多信息</a>。 <code>X-XSS-Protection</code> 这个响应头是用来防范XSS的。最早我是在介绍IE8的文章里看到这个，现在主流浏览器都支持，并且默认都开启了XSS保护，用这个header可以关闭它。它有几种配置： 0：禁用XSS保护； 1：启用XSS保护； 1; mode=block：启用XSS保护，并在检查到XSS攻击时，停止渲染页面（例如IE8中，检查到攻击时，整个页面会被一个#替换）； 浏览器提供的XSS保护机制并不完美，但是开启后仍然可以提升攻击难度，总之没有特别的理由，不要关闭它。 <code>Strict-Transport-Security</code>（简称为 HSTS）可以告诉浏览器，在指定的 max-age 内，始终通过 HTTPS 访问我的博客。即使用户自己输入 HTTP 的地址，或者点击了 HTTP 链接，浏览器也会在本地替换为 HTTPS 再发送请求。另外由于我的证书不支持多域名，我没有加上 includeSubDomains。关于 <a href="https://www.nginx.com/blog/http-strict-transport-security-hsts-and-nginx/" target="_blank" rel="noopener">HSTS</a> 更多信息。 <strong>HTTPS 安全配置</strong> 启用 HTTPS 并正确配置了证书，意味着数据传输过程中无法被第三者解密或修改。有了 HTTPS，也得合理配置好 Web Server，才能发挥最大价值。关于 HTTPS 这一块有以下配置：</p>
<p>worker_processes auto;</p>
<p>http {</p>
<pre><code>#配置会话超时时间
ssl\_session\_timeout  10m;

#配置共享会话缓存大小，视站点访问情况设定
ssl\_session\_cache shared:SSL:10m;

server {
    listen      443 ssl;
    server_name www.example.com;

    #设置长连接
    keepalive_timeout 70;

    #开启HTTPS协议（推荐使用listen指令的ssl参数来代替这个指令）
    #ssl on;

    #证书文件
    ssl_certificate www.example.com.crt;

    #私钥文件
    ssl\_certificate\_key www.example.com.key;

    #使用DH文件
    ssl_dhparam /etc/ssl/certs/dhparam.pem;

    #版本选择
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;

    #定义算法
    ssl_ciphers EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:!MD5;

    #优先采取服务器算法
    ssl\_prefer\_server_ciphers  on;

    #减少点击劫持
    add_header X-Frame-Options DENY;

    #禁止服务器自动解析资源类型
    add_header X-Content-Type-Options nosniff;

    #防XSS攻击
    add_header X-XSS-Protection &quot;1; mode=block&quot;;

    #HSTS策略
    add_header Strict-Transport-Security &quot;max-age=31536000;&quot; always;
}</code></pre><p>}</p>
<p>最终效果在 <a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">ssllabs</a> 中测试结果如下。 <a href="http://www.phpkoo.com/wp-content/uploads/2018/04/ssllabs_20180422092149-1.png" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2018/04/ssllabs_20180422092149-1.png" alt=""></a> 如何配置 ssl_ciphers 可以参考<a href="https://cipherli.st/" target="_blank" rel="noopener">这个网站</a>。需要注意的是，这个网站默认提供的加密方式安全性较高，一些低版本客户端并不支持，例如 IE9-、Android2.2- 和 Java6-。如果需要支持这些老旧的客户端，需要点一下网站上的「Yes, give me a ciphersuite that works with legacy / old software」链接，同时也可以使用 <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="noopener">Mozilla 基金会</a> 来生成配置。 另外 ssl_ciphers 还支持 CHACHA20 加密套件，只要 Nginx 编译时增加了 CHACHA20_POLY1305 加密算法即可，这是由 Google 开发的新一代加密方式，它有两方面优势：更好的安全性和更好的性能（尤其是在移动和可穿戴设备上）。下面有一张移动平台上它与 AES-GCM 的加密速度对比图（via）： <img src="http://www.phpkoo.com/wp-content/uploads/2018/04/chacha.png.webp_.jpg" alt=""> 启用 CHACHA20_POLY1305 最简单的方法是在编译 Nginx 时，使用 LibreSSL 代替 OpenSSL。用 Chrome 访问网站时，点击地址栏小锁显示的信息，可以看到加密方式使用的是不是 CHACHA20_POLY1305。 关于 CHACHA20_POLY1305 安全性和性能的详细介绍可以<a href="https://blog.cloudflare.com/do-the-chacha-better-mobile-performance-with-cryptography/" target="_blank" rel="noopener">查看本文</a>。</p>
<p>补充：<br>1.使用 CHACHA20_POLY1305 的最佳实践是「仅针对不支持 AES-NI 的终端使用 CHACHA20 算法，否则使用 AES-GCM」。</p>
<p>2.我们通过 openssl 工具看一下 ssl_ciphers 具体包含哪些 Cipher Suites 例如：<br>openssl ciphers -V ‘EECDH+AES128’ | column -t</p>
<p>0xC0,0x2F  -  ECDHE-RSA-AES128-GCM-SHA256    TLSv1.2  Kx=ECDH  Au=RSA    Enc=AESGCM(128)  Mac=AEAD<br>0xC0,0x2B  -  ECDHE-ECDSA-AES128-GCM-SHA256  TLSv1.2  Kx=ECDH  Au=ECDSA  Enc=AESGCM(128)  Mac=AEAD<br>0xC0,0x27  -  ECDHE-RSA-AES128-SHA256        TLSv1.2  Kx=ECDH  Au=RSA    Enc=AES(128)     Mac=SHA256<br>0xC0,0x23  -  ECDHE-ECDSA-AES128-SHA256      TLSv1.2  Kx=ECDH  Au=ECDSA  Enc=AES(128)     Mac=SHA256<br>0xC0,0x13  -  ECDHE-RSA-AES128-SHA           SSLv3    Kx=ECDH  Au=RSA    Enc=AES(128)     Mac=SHA1<br>0xC0,0x09  -  ECDHE-ECDSA-AES128-SHA         SSLv3    Kx=ECDH  Au=ECDSA  Enc=AES(128)     Mac=SHA1</p>
<p><strong>加强 HTTPS 安全性</strong> HTTPS 基础配置采取的默认加密算法是 SHA-1，这个算法非常脆弱，安全性在逐年降低，在 2014 年的时候， Google 官方博客就宣布在 Chrome 浏览器中逐渐降低 SHA-1 证书的安全指示，会从 2015 年起使用 SHA-2 签名的证书，可参阅 <a href="http://www.freebuf.com/author/rabbit_run" target="_blank" rel="noopener">Rabbit_Run</a> 在 2014 年发表的文章：<a href="http://www.freebuf.com/news/topnews/44288.html" target="_blank" rel="noopener">《为什么Google急着杀死加密算法SHA-1》</a> 为此，主流的 HTTPS 配置方案应该避免 SHA-1，可以使用 <a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">迪菲-赫尔曼密钥交换（D-H，Diffie–Hellman key exchange）</a>方案。 首先在目录 /etc/ssl/certs 运行以下代码生成 dhparam.pem 文件：</p>
<p>openssl dhparam -out dhparam.pem 2048</p>
<p>关于 ssl_dhparam 的配置，可以参考这篇文章：<a href="https://weakdh.org/sysadmin.html" target="_blank" rel="noopener">Guide to Deploying Diffie-Hellman for TLS</a>。 SSLv3 已被证实不安全，所以在 ssl_protocols 指令中，我并没有包含它。 将 ssl_prefer_server_ciphers 配置为 on，可以确保在 TLSv1 握手时，使用服务端的配置项，以增强安全性。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>https</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 100行代码实现区块链原型</title>
    <url>/posts/414.html</url>
    <content><![CDATA[<p>有人说今年（2018年）是区块链技术元年，作为一种新兴的技术，它不仅弯道超车盖过了人工智能、大数据的风头，而且发展速度更是一日千里。各大厂商都相继推出区块链服务，你可能觉得难以置信。不管你信不信，当你还在熟睡时，有一群人还在挑灯夜战。 在周未闲来无事，虽然之前网上也有各版本的区块链代码，还是动手用golang写了一下，简单实现了区块链的原型。代码如下：</p>
<p>package main</p>
<p>import (<br>    “crypto/sha256”<br>    “encoding/json”<br>    “fmt”<br>)</p>
<p>//Block 结构<br>type Block struct {<br>    Index        int<br>    Timestamp    string<br>    Data         string<br>    PreviousHash string<br>    Hash         string<br>}</p>
<p>//CalculateHash 计算HASH<br>func (b *Block) CalculateHash() string {<br>    s := fmt.Sprintf(“%d%s%s%s”, b.Index, b.PreviousHash, b.Timestamp, b.Data)<br>    sum := sha256.Sum256([]byte(s))<br>    return fmt.Sprintf(“%x”, sum)<br>}</p>
<p>//BlockChain 结构<br>type BlockChain struct {<br>    Chain []*Block<br>}</p>
<p>//NewBlockChain 创建区块链<br>func NewBlockChain() *BlockChain {<br>    bc := &amp;BlockChain{}<br>    bc.Chain = append(bc.Chain, bc.CreateGenesisBlock())<br>    return bc<br>}</p>
<p>//CreateGenesisBlock 创建创世块<br>func (bc *BlockChain) CreateGenesisBlock() *Block {<br>    b := &amp;Block{<br>        Index:        0,<br>        Timestamp:    “2018-01-01”,<br>        Data:         “Genesis Block”,<br>        PreviousHash: “0”,<br>    }<br>    b.Hash = b.CalculateHash()<br>    return b<br>}</p>
<p>//GetLatestBlock 最新区块<br>func (bc *BlockChain) GetLatestBlock() *Block {<br>    return bc.Chain[len(bc.Chain)-1]<br>}</p>
<p>//AddBlock 增加区块<br>func (bc *BlockChain) AddBlock(newBlock *Block) {<br>    newBlock.Index = bc.GetLatestBlock().Index + 1<br>    newBlock.PreviousHash = bc.GetLatestBlock().Hash<br>    newBlock.Hash = newBlock.CalculateHash()<br>    bc.Chain = append(bc.Chain, newBlock)<br>}</p>
<p>//IsChainValid 区块是否有效<br>func (bc *BlockChain) IsChainValid() bool {<br>    for i := 1; i &lt; len(bc.Chain); i++ {<br>        currentBlock := bc.Chain[i]<br>        previousBlock := bc.Chain[i-1]</p>
<pre><code>    if currentBlock.Hash != currentBlock.CalculateHash() {
        return false
    }

    if currentBlock.PreviousHash != previousBlock.Hash {
        return false
    }
}
return true</code></pre><p>}</p>
<p>func main() {<br>    bc := NewBlockChain()<br>    bc.AddBlock(&amp;Block{Timestamp: “2018-02-01”, Data: <code>{&quot;amout&quot;:10}</code>})<br>    bc.AddBlock(&amp;Block{Timestamp: “2018-03-01”, Data: <code>{&quot;amout&quot;:20}</code>})<br>    bc.AddBlock(&amp;Block{Timestamp: “2018-04-01”, Data: <code>{&quot;amout&quot;:30}</code>})</p>
<pre><code>blockchain, _ := json.MarshalIndent(bc, &quot;&quot;, &quot;\\t&quot;)
fmt.Println(string(blockchain))

fmt.Println(&quot;is BlockChain valid &quot;, bc.IsChainValid())</code></pre><p>}</p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>golang</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-lang环境安装</title>
    <url>/posts/396.html</url>
    <content><![CDATA[<p>一、安装Rust 1、如果你之前使用了一个有Windows下GUI安装向导的.msi文件安装了Rust，请到控制面板-&gt;程序与功能(添加/删除程序)里卸载。 2、设置安装路径。默认它会把Rust装到你的<del>/.rustup 里，依赖库下载到</del>/.cargo 里。需要修改的话，设置环境变量RUSTUP_HOME 和 CARGO_HOME 分别修改这两个值（例如D:\.rustup和D:\.cargo）。 [shell] RUSTUP_HOME=D:\.rustup CARGO_HOME=D:\.cargo [/shell] 4、配置代理#1：国内有些地区访问Rustup的服务器不太顺畅，可以配置中科大的Rustup镜像：设置环境变量 [shell] RUSTUP_DIST_SERVER=<a href="http://mirrors.ustc.edu.cn/rust-static" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/rust-static</a> RUSTUP_UPDATE_ROOT=<a href="http://mirrors.ustc.edu.cn/rust-static/rustup" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/rust-static/rustup</a> [/shell] 安装过程中出现以下选项 Proceed with installation (default) Customize installation Cancel installation 选（Customize installation）进行自定义安装 会一步一步问你 1）个问你是否用 default host tripe 我选的是 x86_64-pc-windows-gnu（<a href="https://github.com/rust-lang-nursery/rustup.rs/#other-installation-methods）" target="_blank" rel="noopener">https://github.com/rust-lang-nursery/rustup.rs/#other-installation-methods）</a> 下面有一大堆版本可以选。 假设你是Windows环境，打算编译64位程序，你应该用的是： [shell] x86_64-pc-windows-msvc [/shell] 或 [shell] x86_64-pc-windows-gnu [/shell] 这两个各有优缺点： x86_64-pc-windows-msvc是基于微软的链接器的，稳定性比较好，缺点是依赖的第三方库比较难弄，而且安装时你还需要再装一个微软的Visual C++ Build Tools(含Windows SDK；如果你机器上有Visual Studio就不用装Build Tools了)；到这里去下载 <a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="noopener">http://landinghub.visualstudio.com/visual-cpp-build-tools</a> ，装2015的。（2017的用起来会有点麻烦，Rust团队会在2017年8月解决。如果你看到这篇文章晚于那个时候了，装2017也可以） x86_64-pc-windows-gnu是基于gnu开发工具的windows移植版本的，潜在的bug会多一些，但是第三方库反而容易弄(MSYS2的问题回头再说) 如果需要的话，可以两个都装的，这里你选一个版本就好。 2）个会问你 用哪个版本（stable/beta/nightly/none）我输入 stable 3）个会问你是否 默认修改环境变量 (这个无所谓了可以后期改) 我选是 5、在. cargo 文件夹根目录下创建一个 config 文件 没有任何文件后缀, 内容为: [shell] [registry] index = “<a href="https://mirrors.ustc.edu.cn/crates.io-index/&quot;" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/crates.io-index/&quot;</a> [source.crates-io] registry = “<a href="https://github.com/rust-lang/crates.io-index&quot;" target="_blank" rel="noopener">https://github.com/rust-lang/crates.io-index&quot;</a> replace-with = ‘ustc’ [source.ustc] registry = “<a href="https://mirrors.ustc.edu.cn/crates.io-index/&quot;" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/crates.io-index/&quot;</a> [/shell] 6、将 cargo 加入 path 环境变量: [shell] %CARGO_HOME%\bin [/shell] 前期工作就可以了 那么打开 cmd 输入 检查 rustup 有无安装成功 [shell] rustup -v cargo -v [/shell] 二、安装工具链 因为RLS必须使用nightly版本，所以需要同时安装以下两个工具链 [shell] stable-x86_64-pc-windows-gnu nightly-x86_64-pc-windows-gnu [/shell] 三、安装相关工具 [shell] cargo install rustfmt cargo install rustsym cargo install racer [/shell] 四、项目管理 Rust中一般使用cargo管理项目，比如： 创建项目 [shell]cargo new hellorust –bin[/shell] 编译项目 [shell]cargo build –release[/shell] 运行项目 [shell]cargo run –release[/shell] 清理项目 [shell]cargo clean[/shell] 五、给vscode安装rust插件 1、打开vscode，然后按CRTL+P打开面板，然后安装以下两个插件 [shell]ext install vscode-rust[/shell] [shell]ext install rust[/shell] 然后按提示进行安装即可 2、vscode-rust安装过程中，提示如下错误（没有报错略过） toolchain ‘nightly-x86_64-pc-windows-gnu’ does not contain component ‘rls’ for target ‘x86_64-pc-windows-gnu’ 需要添加rustup的工具链如下，打开cmd工具输入以下命令 [shell] rustup component add rls-preview –toolchain nightly [/shell] 3、设置vscode其中toolchain必须为nightly版本 [shell] “rust.mode”: “rls”, “rust.rls”: { “useRustfmt”: true }, “rust.rustup”: { “toolchain”: “nightly-x86_64-pc-windows-gnu”, “nightlyToolchain”: “nightly-x86_64-pc-windows-gnu” } [/shell]</p>
]]></content>
      <categories>
        <category>Rust-lang</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>rust-lang</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>go build 常见编译优化</title>
    <url>/posts/393.html</url>
    <content><![CDATA[<p>一般情况下，go build 可以直接编译程序，无需额外的参数设定。 但在编译生产环境下使用的可执行程序时候，go build 的一些参数还是很有用的。 减小编译后可执行程序的大小 [shell] go build -ldflags ‘-w -s’ [/shell] 说明： -w 禁止生成debug信息,注意使用该选项后，无法使用 gdb 进行调试 -s 禁用符号表 可以使用 go tool link –help 查看 ldflags 各参数含义 禁止gc优化和内联 [shell] go build -gcflags ‘-N -l’ [/shell] 说明: -N 禁止编译优化 -l 禁止内联,禁止内联也可以一定程度上减小可执行程序大小 可以使用 go tool compile –help 查看 gcflags 各参数含义</p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>build</tag>
        <tag>gola</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Get安装一些第三方库-网络问题</title>
    <url>/posts/391.html</url>
    <content><![CDATA[<p>由于限制问题，国内使用 go get 安装 golang 官方包可能会失败，如我自己在安装golint时，出现了以下报错： [shell] $ go get -u -v golang.org/x/lint/golint Fetching <a href="https://golang.org/x/lint/golint?go-get=1" target="_blank" rel="noopener">https://golang.org/x/lint/golint?go-get=1</a> https fetch failed: Get <a href="https://golang.org/x/lint/golint?go-get=1" target="_blank" rel="noopener">https://golang.org/x/lint/golint?go-get=1</a>: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. [/shell] 不翻墙的情况下怎么解决这个问题？其实 golang 在 github 上建立了一个镜像库，如 <a href="https://github.com/golang/lint" target="_blank" rel="noopener">https://github.com/golang/lint</a> 即是 <a href="https://golang.org/x/lint" target="_blank" rel="noopener">https://golang.org/x/lint</a> 的镜像库 获取 golang.org/x/lint 包，其实只需要以下步骤： [shell] mkdir -p $GOPATH/src/golang.org/x cd $GOPATH/src/golang.org/x git clone <a href="https://github.com/golang/lint.git" target="_blank" rel="noopener">https://github.com/golang/lint.git</a> #执行go install go install golang.org/x/lint/golint [/shell] ps go get实际是从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。所以上面的步骤需要手动go install一下代码包。 go get常用的辅助参数。 -insecure 允许非安全下载，主要是针对没有HTTPS的HTTP路径。 -u 这个很常见，有更新的话会覆盖本地的package，默认不会覆盖的。 -v 显示Log，即verbose. -t 同时下载需要运行测试的package. -d 只下载，但不安装package.</p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode for win10下安装phpcs</title>
    <url>/posts/378.html</url>
    <content><![CDATA[<p>1. 下载并安装 Visual Studio Code 微软官网：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a> 插件库：<a href="https://marketplace.visualstudio.com/#VSCode" target="_blank" rel="noopener">https://marketplace.visualstudio.com/#VSCode</a> 2. 在Windows 10环境下安装PHP 2.1 下载自己中意的PHP版本（我选的是php-7.2.0-Win32-VC15-x64）： PHP官网：<a href="http://windows.php.net/download" target="_blank" rel="noopener">http://windows.php.net/download</a> 2.2 将php-7.2.0-Win32-VC15-x64.zip 解压到D盘根目录（注：也可以解压到C盘），并将php-7.2.0-Win32-VC15-x64文件夹重命名为php，最终php路径如下（注意这个很关键，会影响到后面PHP_CodeSniffer组件的安装）： [shell] D:\php\ [/shell] 2.3 设置环境变量，允许执行PHP 打开高级系统设置（Win+R，然后输入sysdm.cpl打开即可进入，找到Path环境变量，把”D:\php”这个路径加到里面） 2.4 检查PHP环境是否正常（Win+R，然后输入CMD运行，然后执行php -h命令）如下 [shell] php -h [/shell] 2.5 重命名 php.ini ，在php根目录会找到以下两个文件： php.ini-development 开发测试用 php.ini-production 安全性高，适合线上 这里我选择将php.ini-production重命名为php.ini 3. 安装pear库（您也可以另外用composer库，直接看第4步） 3.1 下载<a href="http://pear.php.net/go-pear.phar" target="_blank" rel="noopener">http://pear.php.net/go-pear.phar</a> 3.2 复制go-pear.phar文件到C:\php目录 3.3 继续运行CMD然后确保已经cd到了C:\php&gt;，执行以下命令 [shell] D:\php&gt;php go-pear.phar [/shell] 遇到： Are you installing a system-wide PEAR or a local copy? (system|local) [system] : 输入local继续（什么都不输直接回车，那么表示默认选择system，但这可能存在权限问题而终止） 后面就是yes，Y，回车，一步步按提示进行下去。 3.4 检查php.ini里面已经配置好，结尾会看到： [shell] include_path=”.;D:\php\pear” [/shell] （如果是PHP7可能默认已经做了路径指向，因此pear装完后不会有这句代码） 3.5 CMD里面执行pear，如果返回相应内容即表示pear安装成功： 4. 安装PHPcs 以下是最关键一步，运行CMD，执行以下命令： [shell] D:\php&gt;pear install PHP_CodeSniffer WARNING: channel “pear.php.net” has updated its protocols, use “pear channel-upd ate pear.php.net” to update downloading PHP_CodeSniffer-2.0.0.tgz … Starting to download PHP_CodeSniffer-2.0.0.tgz (448,559 bytes) …………………………………………………………………….. ……….done: 448,559 bytes ERROR: failed to mkdir C:\php\pear\tests\PHP_CodeSniffer\CodeSniffer\Core\File [/shell] 如果出现以下错误： ERROR: failed to mkdir C:\php\pear\tests\PHP_CodeSniffer\CodeSniffer\Core\File 需要设置如下配置，以管理员身份支行cmd分别输入以下命令 [shell] D:\php&gt;pear config-set php_dir D:\php\pear config-set succeeded D:\php&gt;pear config-set doc_dir D:\php\pear config-set succeeded D:\php&gt;pear config-set cfg_dir D:\php\pear config-set succeeded D:\php&gt;pear config-set data_dir D:\php\pear config-set succeeded D:\php&gt;pear config-set test_dir D:\php\pear config-set succeeded D:\php&gt;pear config-set www_dir D:\php\pear config-set succeeded D:\php&gt;pear install PHP_CodeSniffer WARNING: channel “pear.php.net” has updated its protocols, use “pear channel-upd ate pear.php.net” to update downloading PHP_CodeSniffer-2.0.0.tgz … Starting to download PHP_CodeSniffer-2.0.0.tgz (448,559 bytes) ………………………..done: 448,559 bytes install ok: channel://pear.php.net/PHP_CodeSniffer-2.0.0 [/shell] 5. 安装PHP CodeSniffer for Visual Studio Code插件（英文介绍） 5.1 打开 Visual Studio Code； 5.2 在Windows下面按快捷键 Ctrl+P 或者 Mac下面 Cmd+P 来快捷打开对话框； 5.3 键入 ext install phpcs 找到插件： 5.4 直接回车或者点那个云图标来下载和安装此插件； 5.5 重启 Visual Studio Code 就可以享用此强大IDE了。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx（openresty）升级ssl模块 以支持 HTTP/2</title>
    <url>/posts/375.html</url>
    <content><![CDATA[<p>我们并不需要升级系统自带的 openssl，因为随便升级 openssl 会带来安全风险。我们只下载 openssl 1.0.2 源码包，借助它来重新编译（相当于重新安装）服务器上的 NginX 即可。一旦成了 built with OpenSSL 1.0.2，就意味着能够支持 http/2 了。 1、下载并解压 OpenSSL [shell] cd /usr/local/src wget <a href="https://www.openssl.org/source/openssl-1.0.2-latest.tar.gz" target="_blank" rel="noopener">https://www.openssl.org/source/openssl-1.0.2-latest.tar.gz</a> tar -zxf openssl-1.0.2-latest.tar.gz [/shell] 2、修改编译参数 [shell] #指定opensll包位置 –with-openssl=/usr/local/src/openssl-1.0.2m #开启ssl模块 –with-http_ssl_module #开启http/2模块 –with-http_v2_module #编译报错是“collect2: ld returned 1 exit status”需要指定pcre8.36及以上版本 –with-pcre=/usr/local/src/pcre-8.40 [/shell] 3、开启ssl 修改配置 [shell] server { listen 443 ssl; server_name localhost; …. } [/shell] 4、开启http/2 修改配置 [shell] server { listen 443 ssl http2; server_name localhost; …. } [/shell] 附： pcre下载：<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ssl</tag>
        <tag>http/2</tag>
        <tag>openresty</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 安装(升级) OpenSSL</title>
    <url>/posts/373.html</url>
    <content><![CDATA[<p>CentOS 6.x（7.x） 的 OpenSSL 软件版本实在是低，2017 年了还在用人家 2013 年的版本，而且 1.0.1 版本对 ALPN 不支持，已经没法跟上大环境的节奏了 可以看一下默认自带的版本 [shell] # openssl version OpenSSL 1.0.1e-fips 11 Feb 2013 [/shell] 所以我们有必要升级 OpenSSL 到 1.0.2 版本 以下所有操作均需在 root 用户下进行 1、安装必要软件 [shell] yum install gcc gcc-c++ autoconf automake zlib zlib-devel pcre-devel [/shell] 2、下载并解压 OpenSSL [shell] cd /usr/local/src wget <a href="https://www.openssl.org/source/openssl-1.0.2-latest.tar.gz" target="_blank" rel="noopener">https://www.openssl.org/source/openssl-1.0.2-latest.tar.gz</a> tar -zxf openssl-1.0.2-latest.tar.gz [/shell] 3、编译安装 OpenSSL [shell] cd openssl-1.0.2* ./config make &amp;&amp; make install [/shell] 4、移除旧版本 OpenSSL [shell] mv /usr/bin/openssl /tmp/ ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl [/shell] 好了，大功告成，查看一下现在的版本 [shell] # openssl version OpenSSL 1.0.2m 26 Jan 2017 [/shell]</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>一个git的使用错误unable to read askpass</title>
    <url>/posts/369.html</url>
    <content><![CDATA[<p>今天在git push origin master时，竟然出现了错误 (gnome-ssh-askpass:32737): Gtk-WARNING **: cannot open display: error: unable to read askpass response from ‘/usr/libexec/openssh/gnome-ssh-askpass’根本原因是执行了该脚本 [shell] $ cat /etc/profile.d/gnome-ssh-askpass.sh SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass [/shell] 解决方式 [shell] $ unset SSH_ASKPASS [/shell] 再次执行git [shell] $ git push origin master [/shell] 不再提示错误。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>centos一键安装最新内核并开启BBR脚本</title>
    <url>/posts/365.html</url>
    <content><![CDATA[<p>最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，最新的 4.11 版内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。 根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。 于是我根据目前三大发行版的最新内核，开发了一键安装最新内核并开启 TCP BBR 脚本。 本脚本适用环境 [shell] 系统支持：CentOS 6+，Debian 7+，Ubuntu 12+ 虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等 内存要求：≥128M [/shell] 一、关于BBR脚本 [shell] 1、本脚本已在 Vultr 上的 VPS 全部测试通过。 2、当脚本检测到 VPS 的虚拟方式为 OpenVZ 时，会提示错误，并自动退出安装。 3、脚本运行完重启发现开不了机的，打开 VPS 后台控制面板的 VNC, 开机卡在 grub 引导, 手动选择内核即可。 4、由于是使用最新版系统内核，最好请勿在生产环境安装，以免产生不可预测之后果。 [/shell] 二、BBR脚本使用方法 使用root用户登录，运行以下命令： [shell] $ wget –no-check-certificate <a href="https://github.com/teddysun/across/raw/master/bbr.sh" target="_blank" rel="noopener">https://github.com/teddysun/across/raw/master/bbr.sh</a> $ chmod +x bbr.sh $ ./bbr.sh [/shell] 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。 重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令： [shell] $ uname -r 4.13.5-1.el6.elrepo.x86_64 [/shell] [shell] $ sysctl net.ipv4.tcp_available_congestion_control net.ipv4.tcp_available_congestion_control = bbr cubic reno [/shell] [shell] $ sysctl net.ipv4.tcp_congestion_control net.ipv4.tcp_congestion_control = bbr [/shell] [shell] $ sysctl net.core.default_qdisc net.core.default_qdisc = fq [/shell] [shell] $ lsmod | grep bbr tcp_bbr 16384 10 [/shell] 三、内核升级方法 如果是 CentOS 系统，执行如下命令即可升级内核： [shell] $ rpm –import <a href="https://www.elrepo.org/RPM-GPG-KEY-elrepo.org" target="_blank" rel="noopener">https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</a> $ rpm -Uvh <a href="http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm" target="_blank" rel="noopener">http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm</a> $ yum –enablerepo=elrepo-kernel -y install kernel-ml kernel-ml-devel [/shell] CentOS 6 的话，执行命令： [shell] $ sed -i ‘s/^default=.*/default=0/g’ /boot/grub/grub.conf [/shell] CentOS 7 的话，执行命令： [shell] $ grub2-set-default 0 [/shell] 特别说明 1、如果你使用的是 Google Cloud Platform （GCP）更换内核，有时会遇到重启后，整个磁盘变为只读的情况。只需执行以下命令即可恢复： [shell] $ mount -o remount rw / [/shell] 2、如果你使用的是 Linode ，那么无需更换内核，只需修改配置即可开启 BBR： [shell] $ sed -i ‘/net.core.default_qdisc/d’ /etc/sysctl.conf $ sed -i ‘/net.ipv4.tcp_congestion_control/d’ /etc/sysctl.conf $ echo “net.core.default_qdisc = fq” &gt;&gt; /etc/sysctl.conf $ echo “net.ipv4.tcp_congestion_control = bbr” &gt;&gt; /etc/sysctl.conf $ sysctl -p [/shell] 参考博文 <a href="https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95</a> <a href="https://teddysun.com/489.html" target="_blank" rel="noopener">https://teddysun.com/489.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>bbr</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下使用yum安装gcc的几点心得</title>
    <url>/posts/360.html</url>
    <content><![CDATA[<p>1、安装gcc和gcc-c++ [shell] $ yum -y install gcc $ yum -y install gcc-c++ #或者 $ yum groupinstall “Development Tools” #或者 $ yum install gcc gcc-c++ kernel-devel [/shell] 2、yum安装包时提示libstdc++版本冲突 [shell] $ yum downgrade libgomp $ yum downgrade libstdc++ $ yum downgrade libgcc $ yum downgrade cpp [/shell]</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装git</title>
    <url>/posts/353.html</url>
    <content><![CDATA[<p>git是当下比较流行的代码版本管理工具，开源并且免费使用。下面介绍一下安装过程。</p>
<p>1、下载安装包</p>
<p>$ wget <a href="https://www.kernel.org/pub/software/scm/git/git-2.13.2.tar.gz" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git/git-2.13.2.tar.gz</a></p>
<p>2、卸载系统自带的git</p>
<p>$ yum remove git</p>
<p>3、安装必要的依赖包</p>
<p>$ yum -y install gcc perl-devel perl-CPAN tcl tk gettext gettext-devel zlib-devel curl-devel</p>
<p>4、编译安装</p>
<p>$ tar -zxvf git-2.13.2.tar.gz<br>$ cd git-2.13.2<br>$ ./configure<br>$ make<br>$ make install</p>
<p>5、创建链接文件（默认情况下安装到/usr/local/bin/git）</p>
<p>$ ln -s /usr/local/bin/git /usr/bin/git<br>$ git –version<br>git version 2.13.2</p>
<p>到此安装完成</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装lua-imagick插件实现图片缩放等处理</title>
    <url>/posts/344.html</url>
    <content><![CDATA[<p>lua-imagick基于imagemagick图片处理接口，使用lua语言实现的一个模块，以下是模块编译及依赖安装。 一、imagemagick安装（lua-imagick只支持6.9.x版本） 1、下载安装包 [shell] $ wget <a href="https://www.imagemagick.org/download/ImageMagick-6.9.8-6.zip" target="_blank" rel="noopener">https://www.imagemagick.org/download/ImageMagick-6.9.8-6.zip</a> [/shell] 2、编译安装 [shell] $ unzip ImageMagick-6.9.8-6.zip $ cd ImageMagick-6.9.8-6 $ ./configure $ make $ make install [/shell] 二、安装libluajit 1、下载安装包 [shell] $ wget <a href="http://luajit.org/download/LuaJIT-2.0.4.tar.gz" target="_blank" rel="noopener">http://luajit.org/download/LuaJIT-2.0.4.tar.gz</a> [/shell] 2、编译安装 [shell] $ tar zxvf LuaJIT-2.0.4.tar.gz $ cd LuaJIT-2.0.4 $ make $ make install [/shell] 3、下面配置luajit的环境变量(Nginx编译时需要) [shell] $ export LUAJIT_LIB=/usr/local/lib $ export LUAJIT_INC=/usr/local/include/luajit-2.0 [/shell] 三、lua-imagick模块安装 1、下载模块安装包 [shell] $ wget -O lua-imagick.zip <a href="https://codeload.github.com/isage/lua-imagick/zip/master" target="_blank" rel="noopener">https://codeload.github.com/isage/lua-imagick/zip/master</a> [/shell] 2、编译安装 [shell] $ unzip lua-imagick.zip $ cd lua-imagick-master $ cd ./src $ cmake .. -bash: cmake: command not found $ make Scanning dependencies of target imagick [100%] Building C object CMakeFiles/imagick.dir/imagick.c.o Linking C shared module imagick.so $ make install [100%] Built target imagick Install the project… – Install configuration: “” – Installing: /usr/local/lib/lua/5.1/imagick.so – Removed runtime path from “/usr/local/lib/lua/5.1/imagick.so” [/shell] 3、安装cmake工具（如果已经存在，请跳过） [shell] $ yum install -y cmake [/shell] 完成</p>
]]></content>
      <categories>
        <category>LUA</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>LUA</tag>
        <tag>imagick</tag>
      </tags>
  </entry>
  <entry>
    <title>启动docker报错docker: relocation error:symbol dm_task_get_info_with_deferred_remove</title>
    <url>/posts/338.html</url>
    <content><![CDATA[<p>今天从公司一个闲置电脑上装个docker，不料安装没有那么顺利，启动docker有如下报错： [shell] $ docker -d WARN[0000] You are running linux kernel version 2.6.32-431.23.3.el6.x86_64, which might be unstable running docker. Please upgrade your kernel to 3.10.0. INFO[0000] Listening for HTTP on unix (/var/run/docker.sock) docker: relocation error: docker: symbol dm_task_get_info_with_deferred_remove, version Base not defined in file libdevmapper.so.1.02 with link time reference [/shell] 其中警告了kernel升级，这个可以忽略，但还是建议升一下内核，最主要的问题是symbol dm_task_get_info_with_deferred_remove问题 网友提供的解决方案如下： [shell] yum -y upgrade device-mapper-libs [/shell] 瞬间解决了。 ps 系统环境如下： [shell] $ cat /etc/issue CentOS release 6.5 (Final) Kernel \r on an \m $ uname -r 2.6.32-431.23.3.el6.x86_64 [/shell]</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装sshd服务</title>
    <url>/posts/328.html</url>
    <content><![CDATA[<p>sshd是linux下远程管理的一个服务。 1、安装sshd [shell] $ yum install openssh-server -y [/shell] 2、修改配置 [shell] $ vi /etc/ssh/sshd_config PermitRootLogin yes # 是否允许 root 登入！预设是允许的，但是建议设定成 no。 UsePAM no # 利用 PAM 管理使用者认证有很多好处，可以记录与管理。 [/shell] 修改root密码 [shell] passwd [/shell] 重启sshd [shell] service sshd start [/shell]</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>sshd</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器命令速查表</title>
    <url>/posts/323.html</url>
    <content><![CDATA[<p>1.查看容器日志<br>$ docker logs -ft &lt;容器名 or ID&gt;<br> -f 跟踪日志输出<br> -t 显示时间</p>
<p>2.查看容器<br>$ docker ps<br>查看正在运行的容器<br>$ docker ps -a<br>查看所有容器</p>
<p>3.查看docker镜像列表<br>$ docker images</p>
<p>4.删除某个容器<br>$ docker rm &lt;容器名 or ID&gt;<br> -f 强制性删除<br> -v 删除与容器关联的卷</p>
<p>5.删除某个镜像<br>$ docker rmi ID<br> -f 强制性删除</p>
<p>6.停止、启动、杀死一个容器<br>$ docker stop &lt;容器名 or ID&gt;<br>$ docker start &lt;容器名 or ID&gt;<br>$ docker kill &lt;容器名 or ID&gt;</p>
<p>7.运行一个容器<br>$ docker run -it temp bash</p>
<p>8.一个容器连接到另一个容器<br>$ docker run -i -t –name sonar -d -link mmysql:db tpires/sonar-server sonar</p>
<p>9.拉取镜像<br>$ docker pull</p>
<p>10.把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像<br>镜像转成文件：<br>$ docker save<br>&gt; /home/save.tar</p>
<p>使用scp将save.tar拷到机器b上，然后：<br>$ docker load &lt; /home/save.tar</p>
<p>把容器转成文件：<br>$ docker export  &gt; /home/export.tar</p>
<p>使用scp将save.tar拷到机器b上，然后：<br>$ cat /home/export.tar | docker import - export:latest<br>注意：<br>一般情况下，save.tar比export.tar大一点点而已，export比较小，因为它丢失了历史和数据元metadata</p>
<p>11.构建自己的镜像<br>$ docker build -t &lt;镜像名&gt;<br>如Dockerfile在当前路径<br>$ docker build -t Diudiu/gitlab .</p>
<p>12.从Container中拷贝文件出来<br>$ docker cp 7bb0e258aefe:/var/www/laravel/.env .</p>
<p>13.查看docker 存储层的变化<br>$ docker diff &lt; 容器名 or ID &gt;</p>
<p>14.将容器的状态保存为镜像<br>$ docker commit &lt;容器名 or ID&gt;</p>
<p>15.查询可用镜像<br>$ docker search 镜像名称</p>
<p>16.查看一个镜像的历史记录<br>$ docker history ID</p>
<p>17.执行一个容器<br>$ docker exec -it 容器 bash</p>
<p>18.停止所有的container，这样才能够删除其中的images：<br>$ docker stop $(docker ps -a -q)</p>
<p>要kill所有正在运行的容器<br>docker kill $(docker ps -a -q)</p>
<p>要删除所有容器的话再加一个指令：<br>$ docker rm $(docker ps -a -q)</p>
<p>删除所有未打 dangling 标签的镜像<br>$ docker rmi $(docker images -q -f dangling=true)</p>
<p>19.查看当前有些什么images<br>$ docker images</p>
<p>20.删除images，通过image的id来指定删除谁<br>$ docker rmi</p>
<p>想要删除untagged images，也就是那些id为的image的话可以用<br>$ docker rmi $(docker images | grep “^” | awk “{print $3}”)</p>
<p>要删除全部image的话<br>$ docker rmi $(docker images -q)</p>
<p>直接删除带none的镜像<br>$ docker rmi $(docker images | grep “none” | awk ‘{print $3}’)</p>
<p>21.登录镜像仓库<br>$ docker login -u [你的仓库帐号] -p [你的仓库密码] -e Email 仓库地址<br>Login Succeded</p>
<p>22.标记本地镜像<br>$ docker tag [镜像名或ID] 仓库地址/[你的用户名]/[标签名]</p>
<p>23.推送至镜像仓库<br>$ docker push 仓库地址/[你的用户名]/[标签名]</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令及用法整理</title>
    <url>/posts/321.html</url>
    <content><![CDATA[<p><strong>一、docker配置文件</strong> docker启动的配置参数文件 [shell] $ vim /etc/sysconfig/docker other_args=”” [/shell] <strong>二、docker参数说明</strong> 1、指定docker镜像和容器存储路径 –graph=/data/docker 2、指定默认的系统ulimit值 –default-ulimit nproc=65535 <strong>三、docker命令说明</strong> 搜索：docker search centos 下载：docker pull daocloud.io/centos:6 这里使用daocloud提供的centOs6的镜像，系统版本是6.8 查看：docker images 下载好就会出现在镜像列表里 运行：docker run -it -p 22:22   docker run -it daocloud.io/centos:6 /bin/bash -i：允许我们对容器内的STDIN进行交互 -t：在新容器内指定一个伪终端或终端 -d：是后台运行，特别注意，后台运行而不是守护方式运行 –name：指定容器的名称，可用于管理 -P（大写）：将所有公开的端口随机与宿主主机的端口进行绑定 -p（小写）：将宿主机的端口和容器的端口进行绑定。例如：将容器的22端口绑定到宿主机的10022端口上-p 10022:22，也可以同时指定IP绑定-p 127.0.0.1:10022:22 -v：指定该容器挂载宿主机的目录，这样可以通过该目录来实现宿主主机与容器之间数据共享 执行：docker exec -it 容器ID /bin/bash docker ps -l //列出最近一次启动的，且正在运行的container docker ps -a //列出所有的container docker commit -m “备注” 容器id 镜像名:tag版本 //执行完就生成了带sshd的镜像了 注意：先删容器再删镜像 docker rm 容器id //删除单个容器 docker rmi 镜像id //删除单个镜像 docker rm `docker ps -a -q` //删除所有容器 docker rm 容器id //删除容器id为CONTAINER_ID的容器 docker images //查看本地镜像 docker attach 容器id //启动一个已存在的docker实例 docker stop 容器id //停止docker实例（或者直接退出容器登陆；不然这个命令执行后也会强制退出容器的登陆） docker logs 容器id //查看docker实例运行日志，确保正常运行 docker inspect 容器id //查看container的实例属性，比如ip等等</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos6.8下mysql启动时出现mysqld_safe: line 707: ulimit: open files: cannot modify limit: Operation not permitted错误</title>
    <url>/posts/319.html</url>
    <content><![CDATA[<p>mysql启动时出现mysqld_safe: line 707: ulimit: open files: cannot modify limit: Operation not permitted错误 解决方法： [shell] ulimit -n 65535 [/shell] 普通用户ssh连接linux服务器是总是提示： ulimit: open files: cannot modify limit: Operation not permitted 解决方法： [shell] $ vi /etc/security/limits.conf # End of file #添加以下内容： root soft nofile 65535 root hard nofile 65535 * soft nofile 65535 * hard nofile 65535 #优化内核时： * soft nproc 65535 * hard nproc 65535 [/shell] 重启系统</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ulimit</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos6.8下出现bash: scp: command not found lost connection问题解决</title>
    <url>/posts/316.html</url>
    <content><![CDATA[<p>在内网，从一台服务器传mysql的源码安装包到另外一台服务器时，发生如下的错误： [shell] $ scp mysql-5.1.55.tar.gz <a href="mailto:root@192.168.3.22">root@192.168.3.22</a>:. <a href="mailto:root@192.168.3.22">root@192.168.3.22</a>‘s password: bash: scp: command not found lost connection [/shell] 提示scp的命令找不到，但是查找发现命令是存在的 [shell] $ whereis scp scp: /usr/bin/scp /usr/share/man/man1/scp.1.gz [/shell] 如果本地都没有问题，那是另一端服务器上没有安装scp的命令？ [shell] $ whereis scp scp: [/shell] 果真是如此，所以是server端没有找到scp的命令，而不是本地 安装上scp的依赖包 [shell] $ yum install openssh-clients [/shell] 安装好之后，重新传输文件OK。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>安装mysql5.7社区版二进制软件包出现 error while loading shared libraries: libaio.so.1:</title>
    <url>/posts/314.html</url>
    <content><![CDATA[<p>/usr/local/mysql/bin/mysql_install_db –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –user=mysql 在安装二进制mysql的软件包时（版本mysql5.7社区版），初始化中出现 error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory的错误： 解决方法： [shell] $ yum install -y libaio //安装后在初始化就OK了 [/shell]</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>libaio</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下yum安装mcrypt错误：No package php-mcrypt available.解决方法</title>
    <url>/posts/311.html</url>
    <content><![CDATA[<p>错误描述 [shell] $ yum install libmcrypt libmcrypt-devel Setting up Install Process No package libmcrypt-devel available. Error: Nothing to do [/shell] 我们会看到centos yum从仓库中根本找不到这几个包。但我不想使用源码编译就想使用yum安装，怎么办？ 解决方法： [shell] $ yum install epel-release //扩展包更新包 $ yum update //更新yum源 $ yum install libmcrypt libmcrypt-devel //就ok了 [/shell]</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>libmcrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>设置centos的YUM源为国内阿里云源</title>
    <url>/posts/308.html</url>
    <content><![CDATA[<p><strong>1、备份</strong> [shell] $ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup [/shell] <strong>2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/</strong> CentOS 5 [shell] $ wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-5.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/Centos-5.repo</a> [/shell] CentOS 6 [shell] $ wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-6.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/Centos-6.repo</a> [/shell] CentOS 7 [shell] $ wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-7.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/Centos-7.repo</a> [/shell] <strong>3、之后运行yum makecache生成缓存</strong> [shell] $ yum clean all $ yum makecache [/shell] 完成 ps: 1、同步频率为每天一次，每天凌晨2：00-4：00为镜像的同步时间 2、若使用阿里云服务器，将源的域名从mirrors.aliyun.com改为mirrors.aliyuncs.com,不占用公网流量。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker升级至1.9.1版本-Centos6.8</title>
    <url>/posts/305.html</url>
    <content><![CDATA[<p>官方建议使用centos7部署docker1.9.1。 目前，很多系统仍为centos6.8，本文用于测试将centos6.8升级至1.9.1. <strong>查看系统版本</strong> [shell] $ more /etc/issue CentOS release 6.8 (Final) Kernel \r on an \m [/shell] <strong>查看内核版本</strong> [shell] $ uname -r 2.6.32-573.22.1.el6.x86_64 [/shell] <strong>升级内核至3.10</strong> [shell] $ rpm –import <a href="https://www.elrepo.org/RPM-GPG-KEY-elrepo.org" target="_blank" rel="noopener">https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</a> $ cd /etc/yum.repos.d/ $ rpm -ivh <a href="http://www.elrepo.org/elrepo-release-6-5.el6.elrepo.noarch.rpm" target="_blank" rel="noopener">http://www.elrepo.org/elrepo-release-6-5.el6.elrepo.noarch.rpm</a> $ yum –enablerepo=elrepo-kernel install kernel-lt -y [/shell] 升级完毕，修改grup并进行重启。 <strong>修改grub.conf文件default值为0</strong> [shell] $ vim /etc/grub.conf # grub.conf generated by anaconda # # Note that you do not have to rerun grub after making changes to this file # NOTICE: You do not have a /boot partition. This means that # all kernel and initrd paths are relative to /, eg. # root (hd0,0) # kernel /boot/vmlinuz-version ro root=/dev/vda1 # initrd /boot/initrd-[generic-]version.img #boot=/dev/vda default=0 timeout=5 splashimage=(hd0,0)/boot/grub/splash.xpm.gz hiddenmenu title CentOS (3.10.105-1.el6.elrepo.x86_64) root (hd0,0) kernel /boot/vmlinuz-3.10.105-1.el6.elrepo.x86_64 ro root=UUID=55d851da-601d-440a-b119-4fcd9cde4d02 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-3.10.105-1.el6.elrepo.x86_64.img title CentOS (2.6.32-642.6.2.el6.x86_64) root (hd0,0) kernel /boot/vmlinuz-2.6.32-642.6.2.el6.x86_64 ro root=UUID=55d851da-601d-440a-b119-4fcd9cde4d02 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /boot/initramfs-2.6.32-642.6.2.el6.x86_64.img [/shell] <strong>重启系统</strong> [shell] $ reboot [/shell] <strong>重启后查看版本</strong> [shell] $ uname -r 3.10.105-1.el6.elrepo.x86_64 [/shell] <strong>安装docker 1.9.1</strong> [shell] $ curl -sSL -O <a href="https://get.docker.com/builds/Linux/x86_64/docker-1.9.1" target="_blank" rel="noopener">https://get.docker.com/builds/Linux/x86_64/docker-1.9.1</a> &amp;&amp; chmod +x docker-1.9.1 &amp;&amp; mv docker-1.9.1 /usr/local/bin/docker $ cp /usr/local/bin/docker /usr/bin/docker $ service docker start [/shell] <strong>重启后验证</strong> [shell] $ docker version Client: Version: 1.9.1 API version: 1.21 Go version: go1.4.3 Git commit: a34a1d5 Built: Fri Nov 20 17:56:04 UTC 2015 OS/Arch: linux/amd64 Server: Version: 1.9.1 API version: 1.21 Go version: go1.4.3 Git commit: a34a1d5 Built: Fri Nov 20 17:56:04 UTC 2015 OS/Arch: linux/amd64 [/shell]</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker1.9.1</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 6.8下安装docker1.7.1</title>
    <url>/posts/299.html</url>
    <content><![CDATA[<p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>是一个能够把开发应用程序自动部署到容器的开源引擎。它由Docker公司的团队编写，基于Apache 2.0开源协议授权。它提供了一个简单、轻量的建模方式，使开发生命周期更高效快速，鼓励了面向服务的架构设计。 <strong>前提条件</strong> <strong>内核</strong> Docker运行对内核要求比较高，因此一般建议直接在Ubuntu这样的平台运行。但作为一个容器标准，Docker也是支持其他如CentOS, Mac OS X, Windows等平台。目前Docker支持以下版本CentOS: <em>CentOS 7(64位)</em> <em>CentOS 6.5(64位)及以后</em> 在运行CentOS 6.5及以后版本时，需要内核版本&gt;=2.6.32-431，因为这些内核包含了运行Docker的一些特定修改。 [shell] $ uname -r 2.6.32-573.22.1.el6.x86_64 [/shell] <strong>Device Mapper</strong> Docker默认使用AUFS作为存储驱动，但是AUFS并没有被包括在Linux的主线内核中。CentOS中可以使用Device Mapper作为存储驱动，这是在2.6.9内核版本引入的新功能。我们需要先确认是否启用该功能: [shell] $ ls -l /sys/class/misc/device-mapper lrwxrwxrwx 1 root root 0 Mar 11 17:06 /sys/class/misc/device-mapper -&gt; ../../devices/virtual/misc/device-mapper [/shell] 如果没有检测到Device Mapper，需要安装device-mapper软件包: [shell] $ yum install -y device-mapper [/shell] 然后重新加载dm_mod内核模块: [shell] $ modprobe dm_mod [/shell] <strong>第一步 Enable EPEL</strong> 对于CentOS6.8, Docker可以在EPEL源里面找到，所以我们首先需要确保启用EPEL。 [shell] $ yum -y install epel-release-6-8.noarch [/shell] <strong>第二步 Install Docker-IO</strong> 最后需要安装docker-io的RPM包。 [shell] $ yum -y install docker-io [/shell] 这样完成了Docker的安装。 [shell] $ docker -v Docker version 1.7.1, build 786b29d/1.7.1 [/shell] <strong>启动</strong> <strong>第一步 启动服务</strong> 一旦安装好Docker之后，我们需要启动Docker Deamon: [shell] $ service docker start [/shell] <strong>第二步 设置开机启动(可选)</strong> 如果希望Docker Deamon开机运行，还需要做如下操作: [shell] $ chkconfig docker on [/shell] <strong>验证</strong> <strong>验证Docker Deamon</strong> 启动服务后，直接用docker info命令确认docker是否正确安装并运行: [shell] $ docker info Containers: 1 Images: 4 Storage Driver: devicemapper Pool Name: docker-202:1-1835598-pool Pool Blocksize: 65.54 kB Backing Filesystem: extfs Data file: /dev/loop0 Metadata file: /dev/loop1 Data Space Used: 541.8 MB Data Space Total: 107.4 GB Data Space Available: 28.89 GB Metadata Space Used: 983 kB Metadata Space Total: 2.147 GB Metadata Space Available: 2.147 GB Udev Sync Supported: true Deferred Removal Enabled: false Data loop file: /var/lib/docker/devicemapper/devicemapper/data Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata Library Version: 1.02.117-RHEL6 (2016-08-15) Execution Driver: native-0.2 Logging Driver: json-file Kernel Version: 2.6.32-573.22.1.el6.x86_64 Operating System: <unknown> CPUs: 1 Total Memory: 994.6 MiB Name: iZ23l4s2070Z ID: CGIV:KQ7V:LP5I:NF5V:ZMKG:4AK3:RMDZ:QLVL:BY6F:GQF3:V7E5:TDCA [/shell] <strong>验证Docker Client</strong> 现在就让我们验证下Docker是否能正常运行，首先我们来获取centos6.8的镜像: [shell] $ docker pull daocloud.io/centos:6 [/shell] 这里使用的是DaoCloud源，因为官方源在国内不稳定。国内其它源地址：1、<a href="https://c.163.com/hub" target="_blank" rel="noopener">https://c.163.com/hub</a> 2、<a href="http://hub.daocloud.io" target="_blank" rel="noopener">http://hub.daocloud.io</a>，但要求Docker版本&gt;=1.3.2。然后我们检查是否能看到镜像: [shell] $ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE daocloud.io/centos 6 10611b26a8b9 4 months ago 194.6 MB [/shell] 激动的时刻到了，让我们运行一下: [shell] $ docker run -i -t daocloud.io/centos /bin/bash [/shell] 一切正常的话，你会看到一个终端提示符，然后你就可以像操作任何CentOS机器一样进行你的体验。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>centos6.8</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6 安装vsftpd</title>
    <url>/posts/290.html</url>
    <content><![CDATA[<p>CentOS配置vsftp服务器，特殊情况下方便快速管理文件。 1、安装vsftpd [shell] yum -y install vsftpd [/shell] 2、配置vsftpd.conf文件（修改下面中文部分内容） [shell] vi /etc/vsftpd/vsftpd.conf [/shell] [shell] # Example config file /etc/vsftpd/vsftpd.conf # # The default compiled in settings are fairly paranoid. This sample file # loosens things up a bit, to make the ftp daemon more usable. # Please see vsftpd.conf.5 for all compiled in defaults. # # READ THIS: This example file is NOT an exhaustive list of vsftpd options. # Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd’s # capabilities. # # Allow anonymous FTP? (Beware - allowed by default if you comment this out). # 是否允许匿名登录（将其禁止） #anonymous_enable=YES # # 允许使用本地帐户进行FTP用户登录验证 # Uncomment this to allow local users to log in. local_enable=YES # # Uncomment this to enable any form of FTP write command. write_enable=YES # # Default umask for local users is 077. You may wish to change this to 022, # if your users expect that (022 is used by most other ftpd’s) local_umask=022 # # Uncomment this to allow the anonymous FTP user to upload files. This only # has an effect if the above global write enable is activated. Also, you will # obviously need to create a directory writable by the FTP user. #anon_upload_enable=YES # # Uncomment this if you want the anonymous FTP user to be able to create # new directories. #anon_mkdir_write_enable=YES # # Activate directory messages - messages given to remote users when they # go into a certain directory. dirmessage_enable=YES # # The target log file can be vsftpd_log_file or xferlog_file. # This depends on setting xferlog_std_format parameter xferlog_enable=YES # # Make sure PORT transfer connections originate from port 20 (ftp-data). connect_from_port_20=YES # # If you want, you can arrange for uploaded anonymous files to be owned by # a different user. Note! Using “root” for uploaded files is not # recommended! #chown_uploads=YES #chown_username=whoever # # The name of log file when xferlog_enable=YES and xferlog_std_format=YES # WARNING - changing this filename affects /etc/logrotate.d/vsftpd.log #xferlog_file=/var/log/xferlog # # Switches between logging into vsftpd_log_file and xferlog_file files. # NO writes to vsftpd_log_file, YES to xferlog_file xferlog_std_format=YES # # You may change the default value for timing out an idle session. # 设置连接超时时间（单位秒） idle_session_timeout=600 # # You may change the default value for timing out a data connection. # 数据传输超时时间（单位秒） data_connection_timeout=120 # # It is recommended that you define on your system a unique user which the # ftp server can use as a totally isolated and unprivileged user. #nopriv_user=ftpsecure # # Enable this and the server will recognise asynchronous ABOR requests. Not # recommended for security (the code is non-trivial). Not enabling it, # however, may confuse older FTP clients. #async_abor_enable=YES # # By default the server will pretend to allow ASCII mode but in fact ignore # the request. Turn on the below options to have the server actually do ASCII # mangling on files when in ASCII mode. # Beware that on some FTP servers, ASCII support allows a denial of service # attack (DoS) via the command “SIZE /big/file” in ASCII mode. vsftpd # predicted this attack and has always been safe, reporting the size of the # raw file. # ASCII mangling is a horrible feature of the protocol. # 是否允许上传/下载二进制文件 ascii_upload_enable=YES ascii_download_enable=YES # # You may fully customise the login banner string: #ftpd_banner=Welcome to blah FTP service. # # You may specify a file of disallowed anonymous e-mail addresses. Apparently # useful for combatting certain DoS attacks. #deny_email_enable=YES # (default follows) #banned_email_file=/etc/vsftpd/banned_emails # # You may specify an explicit list of local users to chroot() to their home # directory. If chroot_local_user is YES, then this list becomes a list of # users to NOT chroot(). # 限制所有的本地用户只能访问自己的目录 chroot_local_user=YES # 当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd/chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。 #chroot_list_enable=YES # (default follows) #chroot_list_file=/etc/vsftpd/chroot_list # # You may activate the “-R” option to the builtin ls. This is disabled by # default to avoid remote users being able to cause excessive I/O on large # sites. However, some broken FTP clients such as “ncftp” and “mirror” assume # the presence of the “-R” option, so there is a strong case for enabling it. # 是否允许使用ls -R等命令 ls_recurse_enable=YES # # When “listen” directive is enabled, vsftpd runs in standalone mode and # listens on IPv4 sockets. This directive cannot be used in conjunction # with the listen_ipv6 directive. listen=YES # # This directive enables listening on IPv6 sockets. To listen on IPv4 and IPv6 # sockets, you must run two copies of vsftpd with two configuration files. # Make sure, that one of the listen options is commented !! #listen_ipv6=YES pam_service_name=vsftpd userlist_enable=YES userlist_file=/etc/vsftpd/user_list # [新增]是否只允许userlist_file文件中的用户登录FTP服务器，userlist_enable为YES才生效 # YES，默认值，禁止文件中的用户登录，同时也不向这些用户发出输入密码的提示。NO，只允许在文件中的用户登录FTP服务器 userlist_deny=NO tcp_wrappers=YES # [新增]所有用户的根目录（对匿名用户无效，不设置时，默认为用户的家目录/home/ftpuser） local_root=/data [/shell] 3、新增ftp用户并为其设置密码 [shell] useradd -d /home/ftpuser -s /sbin/nologin ftpuser passwd ftpuser [/shell] 4、编辑user_list文件，给予ftpuser用户访问ftp权限 [shell] vim /etc/vsftpd/user_list [/shell] 在文件末尾加入ftpuser并保存 5、建立可访问目录并指定用户 [shell] mkdir -p /data chown -R ftpuser /data/ #注意后面有个/ chmod -R 755 /data [/shell] 6、启动vsftpd服务 [shell] service vsftpd start [/shell] 7、开机启动vsftpd服务 [shell] chkconfig vsftpd on [/shell] 至此完毕</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>vsftp</tag>
      </tags>
  </entry>
  <entry>
    <title>M3U8解析</title>
    <url>/posts/173.html</url>
    <content><![CDATA[<p>3.2 HLS标签说明 3.2.1 EXT-X-TARGETDURATION 该标签指定了媒体文件持续时间的最大值，播放文件列表中的媒体文件在EXTINF标签中定义的持续时间必须小于或者等于该标签指定的持续时间。该标签在播放列表文件中必须出现一次，其格式为： # EXT-X-TARGETDURATION：<s>  s是一个以秒为单位的整数。 3.2.2 EXT-X-MEDIA-SEQUENCE 播放列表文件中每个媒体文件的URI都有一个唯一的序列号。URI的序列号等于它之前那个RUI的序列号加一。EXT-X-MEDIA-SEQUENCE指明了出现在播放列表文件中的第一个URI的序列号。其格式如下： #EXT-X-MEDIA-SEQUENCE：<Number>  播放列表文件中的EXT-X-MEDIA-SEQUENCE标签不能多于一个。如果播放列表文件中没有EXT-X-MEDIA-SEQUENCE标签，那么将会把播放列表中第一个URI的序列号当成0。 <strong>注：</strong>媒体文件的序列号码不是必须出现在它的URI中的。见6.3.2和6.3.5。 3.2.3 EXT-X-KEY 媒体文件可能是被加密的，EXT-X-KEY提供了解密媒体文件的必要信息，它的格式如下： #EXT-X-KEY：METHOD=<method> [,URI = “<uri>”] [,IV = <iv>] Method属性指定了加密方法，定义了两种加密方法：NONE和AES-128。 加密方法NONE表示媒体文件不被加密，如果加密方法是NONE，那么URI和IV属性不允许存在。 加密方法AES-128表示媒体文件使用高级加密标准128位密钥和PKCS7 padding加密。如果加密方法是AES-128，那么对于URI属性，如果存在，则指定获取密钥的方法；对于IV属性，如果存在，则指定使用密钥的初始化向量。 IV属性出现在协议版本2中，新的EXT-X-KEY将会取代任何一个先前的EXT-X-KEY。 如果播放列表文件没有包含EXT-X-KEY标签，那么媒体文件将不会被加密。 密钥文件的格式见第五章，媒体文件加密信息见5.2、6.2.3、6.3.6。 3.2.4 EXT-X-PROGRAM-DATE-TIME EXT-X-PROGRAM-DATE-TIME标签将下一个媒体文件的开头和绝对日期关联起来。日期/时间的表示基于ISO/IEC，并且要指明时区。例如： #EXT-X-PROGRAM-DATE-TIME:&lt;YYYY–MM–DDThh:mm:ssZ&gt; 详见6.2.1和6.3.3 3.2.5 EXT-X-ALLOW-CATCH EXT-X-ALLOW-CATCH标签指定客户端可以或者不准缓存下载的媒体文件用来重播。它可能会出现在播放列表文件的任何地方，但是不能出现两次或以上。该标签适用于播放列表中的所有分片。其格式如下： #EXT-X-ALLOW-CACHE:&lt;YES|NO&gt; 详见6.3.3 3.2.6 EXT-X-ENDLIST EXT-X-ENDLIST标签标示没有更多媒体文件将会加入到播放列表中，它可能会出现在播放列表文件的任何地方，但是不能出现两次或以上。其格式如下： #EXT-X-ENDLIST 3.2.7 EXT-X-STREAM-INF EXT-X-STREAM-INF标签表示在播放列表中的下一个URI标识另一个播放列表文件。格式如下： #EXT-X-STREAM-INF:[attribute=value][,attribute=value]* <URI> 在一个EXT-X-STREAM-INF标签中attribute不能出现两次或以上。其它属性定义： BANDWIDTH = <n> n为每秒比特数,它必须是每个媒体文件比特速率的上限，必须经过计算包含那些在播放列表中出现的或者将要出现的容器开销。 PROGRAM-ID=<i> i是一个数字，在播放列表文件的范围内唯一的标识了一个特定的演示文稿。 一个播放列表文件可能包含多个具有相同PROGRAM-ID 的EXT-X-STREAM-INF标签来标识某个演示文稿的不同编码。这些变种的的播放列表可能包含额外的EXT-X-STREAM-INF标签。 CODECS=”[format][,format]*” 每一种格式都指定了存在于媒体文件中的媒体类型。合法的格式标示符都是那些在ISO文件格式名称空间被RFC4281定义的格式。 RESOLUTION=<N>x<M> N是流中视频水平编码分辨率的近似，以像素数表示，M是编码垂直分辨率的近似。 3.2.8 EXT-X-DISCONTINUITY EXT-X-DISCONTINUITY标签表示该标签后边的媒体文件和之前的媒体文件之间的编码间断。特性可能改变的一组是： file format number and type of tracks encoding parameters encoding sequence 详见第四章，6.2.1、6.3.3。 3.2.9 EXT-X-VERSION EXT-X-VERSION标签指出了播放列表版本的适应性。播放列表文件、其关联的媒体和服务器必须遵守最新版本的所有规定。 4 多媒体文件 每一个媒体文件资源定位符都必须标识一个媒体文件，该文件是整体数据的一个分片。每个媒体文件必须按照MPEG-2的传输流和MPEG-2音频流的格式。[ISO13818] 传输流文件必须包含一个MPEG-2节目。在每个文件的开始应该有一个节目关联表和一个节目映射表。包含视频的文件应该有至少一个密钥帧和足够的信息来完全初始化一个视频解码器。 播放列表中的媒体文件必须是编码流中媒体文件的末尾与先前的序列号的延续，除非它是播放列表中出现的第一个媒体文件，或者它前边有EXT-X-DISCONTINUITY标签。 客户端应该准备好处理一个特定类型（音频或视频等）的多个轨道。一个没有优先级的客户端应该选择它能播放的具有最小数字编号的音轨。 客户端应该忽略那些传输流的内部不能识别的流。 媒体文件内样本流和相应的多媒体流的编码参数应保持一致。然而客户端应该解决编码的变化问题，例如缩放视频内容以适应分辨率改变。 URI属性中EXT-X-KEY标签标识一个密钥文件。密钥文件包含解密播放列表中媒体文件的密钥。AES-128加密算法使用16字节的密钥。密钥文件的格式为16字节的二进制数数组。</p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>hls</tag>
        <tag>m3u8</tag>
      </tags>
  </entry>
  <entry>
    <title>一张图掌握Git</title>
    <url>/posts/282.html</url>
    <content><![CDATA[<p><a href="http://www.phpkoo.com/wp-content/uploads/2017/02/4774497-dcb0ae305248e62d.png" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2017/02/4774497-dcb0ae305248e62d.png" alt=""></a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装mysql5.7社区版</title>
    <url>/posts/272.html</url>
    <content><![CDATA[<p>mysql分社区版和企业版，其中社区版为免费使用并且开源。 1、下载mysql5.7社区版（64位） [shell] wget <a href="http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-linux-glibc2.5-x86\_64.tar" target="_blank" rel="noopener">http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-linux-glibc2.5-x86\_64.tar</a> tar -xvf mysql-5.7.17-linux-glibc2.5-x86_64.tar tar -zxvf mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz [/shell] 2、解压拷贝 [shell] mv mysql-5.7.17-linux-glibc2.5-x86_64 /usr/local/mysql [/shell] 3、创建mysql用户 [shell] groupadd mysql useradd -r -g mysql mysql [/shell] 4、创建mysql的数据目录，该目录在初始化数据库的时候会用到 [shell] mkdir /usr/local/mysql/data /usr/local/mysql/log chown -R mysql:mysql /usr/local/mysql [/shell] 5、创建my.cnf文件 [shell] cp /usr/local/mysql/support-files/my-default.cnf /etc/my.cnf vim /etc/my.cnf [client] port = 3306 socket = /tmp/mysql.sock [mysqld] server_id=1 port = 3306 user = mysql socket = /tmp/mysql.sock basedir = /usr/local/mysql datadir = /usr/local/mysql/data pid-file = /usr/local/mysql/data/mysql.pid max_connections = 1000 max_connect_errors = 1000 table_open_cache = 1024 max_allowed_packet = 128M open_files_limit = 65535 #####====================================[innodb]============================== innodb_buffer_pool_size = 1024M innodb_file_per_table = 1 innodb_write_io_threads = 4 innodb_read_io_threads = 4 innodb_purge_threads = 2 innodb_flush_log_at_trx_commit = 1 innodb_log_file_size = 512M innodb_log_files_in_group = 2 innodb_log_buffer_size = 16M innodb_max_dirty_pages_pct = 80 innodb_lock_wait_timeout = 30 innodb_data_file_path=ibdata1:1024M:autoextend #####====================================[log]============================== log_error = /usr/local/mysql/log/mysql-error.log slow_query_log = 1 long_query_time = 1 slow_query_log_file = /usr/local/mysql/log/mysql-slow.log sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION [/shell] 6、初始化数据库 [shell] /usr/local/mysql/bin/mysql_install_db –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –user=mysql [/shell] 7、修改目录权限 [shell] chown -R mysql:mysql /usr/local/mysql [/shell] 8、配置启动文件 [shell] cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld [/shell] 9、启动mysql [shell] /etc/init.d/mysqld start [/shell] 10、获取初始密码 [shell] cat ~/.mysql_secret rm -rf ~/.mysql_secret [/shell] 11、重设初始密码 [shell] /usr/local/mysql/bin/mysql -uroot -p mysql&gt; show databases; ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. mysql&gt; ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘<strong>****</strong>‘; mysql&gt; grant all privileges on <em>.</em> to root@’%’ identified by ‘123456’; mysql&gt; flush privileges; [/shell] ps:远程连接mysql，报can’t connect to mysql server on ‘localhost’ (10060) 请检查一下iptables，默认可能禁用了3306端口 [shell] vim /etc/sysconfig/iptables -A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT [/shell] 重启iptables [shell] service iptables restart [/shell] PS: 1、创建用户 [shell] CREATE USER ‘username’@’host’ IDENTIFIED BY ‘password’; [/shell] 说明： username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符% password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 2、授权 [shell] GRANT privileges ON databasename.tablename TO ‘username’@’host’ [/shell] 说明： privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.* 注意： 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: [shell] GRANT privileges ON databasename.tablename TO ‘username’@’host’ WITH GRANT OPTION; [/shell] 3、设置与更改用户密码 [shell] SET PASSWORD FOR ‘username’@’host’ = PASSWORD(‘newpassword’); [/shell] 如果是当前登陆用户用 [shell] SET PASSWORD = PASSWORD(“newpassword”); [/shell] 4、撤销用户权限 [shell] REVOKE privilege ON databasename.tablename FROM ‘username’@’host’; [/shell] 说明： privilege, databasename, tablename：同授权部分 注意： 假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。 具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。 5、删除用户 [shell] DROP USER ‘username’@’host’; [/shell]</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装php7的mongodb模块</title>
    <url>/posts/267.html</url>
    <content><![CDATA[<p>php一共有两个模块分别为mongo和mongodb，其中php7只支持mongodb模块 1.安装依赖包 [shell] yum install autoconf [/shell] 2.下载mongodb模块 [shell] wget -O mongodb-1.1.9.tgz <a href="https://pecl.php.net/get/mongodb" target="_blank" rel="noopener">https://pecl.php.net/get/mongodb</a> tar -zxvf mongodb-1.1.9.tgz cd mongodb-1.1.9 [/shell] 3.编译与安装 [shell] /usr/local/php/bin/phpize ./configure –with-php-config=/usr/local/php/bin/php-config make make install [/shell] 安装完成</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>centos</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos下 Nginx安装与配置</title>
    <url>/posts/261.html</url>
    <content><![CDATA[<p>首先由于nginx的一些模块依赖一些lib库，所以在安装nginx之前，必须先安装这些lib库，这些依赖库主要有g++、gcc、openssl-devel、pcre-devel和zlib-devel 所以执行如下命令安装 1.安装依赖包 [shell] yum install gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel ncurses-devel perl [/shell] 2.下载最新版的nginx [shell] wget <a href="http://nginx.org/download/nginx-1.10.2.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.10.2.tar.gz</a> tar -zxvf nginx-1.10.2.tar.gz [/shell] 3.编译与安装 [shell] ./configure –prefix=/usr/local/nginx make make install [/shell] 4.查看nginx的安装目录 [shell] whereis nginx [/shell] 5.启动 [shell] /usr/local/nginx [/shell] 安装完成</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装php7</title>
    <url>/posts/259.html</url>
    <content><![CDATA[<p>编译安装 php-fpm 1.下载php7 [shell] wget -O php7.tar.gz <a href="http://cn2.php.net/get/php-7.0.13.tar.gz/from/this/mirror" target="_blank" rel="noopener">http://cn2.php.net/get/php-7.0.13.tar.gz/from/this/mirror</a> tar -zxvf php7.tar.gz cd php-7.0.13 [/shell] 2.安装依赖包 [shell] yum install gcc gcc-c++ libxml2 libxml2-devel openssl openssl-devel bzip2 bzip2-devel libcurl libcurl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gmp gmp-devel libmcrypt libmcrypt-devel readline readline-devel libxslt libxslt-devel [/shell] 3.编译配置（如果出现错误，基本都是上一步的依赖文件没有安装所致） 可以从这一步起参考PHP官方安装说明：<a href="http://php.net/manual/zh/install.unix.nginx.php" target="_blank" rel="noopener">http://php.net/manual/zh/install.unix.nginx.php</a> [shell] ./configure \ –prefix=/usr/local/php \ –with-config-file-path=/usr/local/php/etc \ –enable-fpm \ –enable-inline-optimization \ –disable-debug \ –disable-rpath \ –enable-shared \ –enable-soap \ –with-libxml-dir \ –with-xmlrpc \ –with-openssl \ –with-mhash \ –with-pcre-regex \ –with-sqlite3 \ –with-zlib \ –enable-bcmath \ –with-iconv \ –with-bz2 \ –enable-calendar \ –with-curl \ –with-cdb \ –enable-dom \ –enable-exif \ –enable-fileinfo \ –enable-filter \ –with-pcre-dir \ –enable-ftp \ –with-gd \ –with-openssl-dir \ –with-jpeg-dir \ –with-png-dir \ –with-zlib-dir \ –with-freetype-dir \ –with-gettext \ –with-gmp \ –with-mhash \ –enable-json \ –enable-mbstring \ –enable-mbregex \ –enable-mbregex-backtrack \ –with-libmbfl \ –with-onig \ –enable-pdo \ –with-mysqli=mysqlnd \ –with-pdo-mysql=mysqlnd \ –with-zlib-dir \ –with-pdo-sqlite \ –with-readline \ –enable-session \ –enable-shmop \ –enable-simplexml \ –enable-sockets \ –enable-sysvmsg \ –enable-sysvsem \ –enable-sysvshm \ –enable-wddx \ –with-libxml-dir \ –with-xsl \ –enable-zip \ –enable-mysqlnd-compression-support \ –with-pear \ –enable-opcache [/shell] 4.正式安装 [shell] make &amp;&amp; make install [/shell] 5.配置环境变量 [shell] cat &gt;&gt;/etc/profile&lt;&lt;EOF export PATH=\$PATH:/usr/local/php/bin EOF [/shell] 6.导入环境变量 [shell] source /etc/profile [/shell] 7.配置php-fpm [shell] cp php.ini-production /usr/local/php/etc/php.ini cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf cp /usr/local/php/etc/php-fpm.d/<a href="http://www.conf.default" target="_blank" rel="noopener">www.conf.default</a> /usr/local/php/etc/php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a> cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm chmod +x /etc/init.d/php-fpm [/shell] 8.启动php-fpm [shell] /etc/init.d/php-fpm start [/shell] 安装完成 ps: 有2种方式可以找到之前的编译参数： 1.在源码 /lamp/php-5.4.11/中找到 config.nice，这个就是之前的编译参数 2.去掉enable-gd-jis-conv编译参数，引起imagettftext()中文乱码问题 3.在php.ini配置文件中找到Configure相关的配置 : [shell] /usr/local/php/bin/php -i |grep ‘Configure’ [/shell]</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>php7</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下php7支持memcached</title>
    <url>/posts/253.html</url>
    <content><![CDATA[<p>php7出了！性能提升一倍！<br>不过兼容性好像还不太好，我在php7下安装memcached扩展遇到了问题，记录一下。</p>
<p>1. 首先需要安装libmemcached支持：<br>官网在此，找到最新版的下载链接 <a href="https://launchpad.net/libmemcached，使用wget下载tar.gz压缩包，解压缩，进入目录，依次执行（prefix后为安装目录）：" target="_blank" rel="noopener">https://launchpad.net/libmemcached，使用wget下载tar.gz压缩包，解压缩，进入目录，依次执行（prefix后为安装目录）：</a></p>
<p>[shell] ./configure –prefix=/usr/local/libmemcached make make install [/shell]</p>
<p>2. 安装memcached<br>php使用memcache的扩展有两个，一个memcache，一个memcached，前者比较老，推荐使用第二个，我们这里以第二个为例：<br>在github上找到适用于php7的分支（<a href="https://github.com/php-memcached-dev/php-memcached/tree/php7），同样使用wget下载zip压缩包，解压缩，进入目录，依次执行下列命令（其中php-config和libmemcached目录根据具体情况设定，可以使用whereis或者find来查找）：" target="_blank" rel="noopener">https://github.com/php-memcached-dev/php-memcached/tree/php7），同样使用wget下载zip压缩包，解压缩，进入目录，依次执行下列命令（其中php-config和libmemcached目录根据具体情况设定，可以使用whereis或者find来查找）：</a></p>
<p>[shell] /usr/local/php/bin/phpize ./configure –with-php-config=/usr/local/php/bin/php-config –enable-memcached-sasl make make install [/shell]</p>
<p>安装成功</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>php-memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>AAC编码基本说明</title>
    <url>/posts/218.html</url>
    <content><![CDATA[<p>Advanced Audio Coding (AAC) 是 MP3 的后继格式，它被定义於 MPEG-4 part 3 (ISO/IEC 14496-3)。它通常使用在 MP4 容器内；对于音乐习惯上使用 .m4a 副档名。第二常见使用是在 MKV (Matroska) 档内，因为它比 MP4 支援更多以文字为基础的软字幕 (例如 ass, ssa…)。本文中的范例将使用 MP4 与 M4A 副档名。 ​ FFmpeg 可以支援 4 个 AAC-LC 编码器 (aac, libfaac, libfdk_aac, libvo_aacenc) 与两个 AAC-HE 编码器 (libaacplus, libfdk_aac)。libaacplus, libfaac, libfdk_aac 的授权不与 GPL 相容，所以当 GPU 授权源代码也包含在内时 GPU 不允许包含源代码授权依据这些授权的二进位档的发布。因此这些编码器被指定为 “non-free”，且你不能下载内建它们的 ffmpeg。这可以透过自行编译 ffmpeg 来解决。 对于 AAC-LC 品质而言，其答案可能是: libfdk_aac &gt; libfaac &gt; Native FFmpeg AAC encoder (aac) &gt; libvo_aacenc <a href="https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio#AudioencodersFFmpegcanuse" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio#AudioencodersFFmpegcanuse</a> <strong>libfdk_aac</strong> The Fraunhofer FDK AAC 编解码程式库。这是目前 ffmpeg 所能提供的最高品质 AAC 编码器。需要 ffmpeg 组态 (configuration) 中含有 –enable-libfdk-aac (如果也使用 –enable-gpl 则还需要 –enable-nonfree)。 详细资料: Fraunhofer FDK AAC - Hydrogenaud Constant Bit Rate (CBR, 常数位元速率) 模式 指定一个目标位元速率。它可以让你精準控制输出档案大小 (= 位元率 * 时间长度)，且它与 HE-AAC profile 相容。由经验得知，双声道推荐 位元率 &gt;= 128kbps，6 声道则推荐位元率 &gt;= 384kbps (由 双声道位元率 * 声道数 / 2)。使用 -b 选项来控制输出位元速率。 范例: 转换一个音讯档为 AAC 并以 M4A (MP4) 容器来封装: [shell] ffmpeg -i input.wav -c:a libfdk_aac -b:a 128k output.m4a [/shell] 转换一个影片的 5.1 生到音讯为 AAC，并复制其视讯串流: [shell] ffmpeg -i input.mp4 -c:v copy -c:a libfdk_aac -b:a 384k output.mp4 [/shell] Variable Bit Rate (VBR, 可变位元速率) 模式 指定一个目标品质，而不是特定的位元速率。设定值范围为 1-5，较高的值会得到较高的位元率与品质。使用 -vbr 选项来设定 VBR 等级。 范例: 转换一个音讯档为 AAC 并以 M4A (MP4) 容器来封装: [shell] ffmpeg -i input.wav -c:a libfdk_aac -vbr 3 output.m4a [/shell] 转换一个影片的 5.1 生到音讯为 AAC，并复制其视讯串流: [shell] ffmpeg -i input.mp4 -c:v copy -c:a libfdk_aac -vbr 3 output.mp4 [/shell] <strong>High-Efficiency AAC</strong> 简称 AAC-HE 又名为 aacPlus，这是一对专门针对低位元速率的 AAC profiles (version 1 与 version 2)，AAC-HE v1。对于双声道而言 (如下图所示)，AAC-HE v1 适用于 96kbps 以下，而 AAC-HE v2 适用于 48kbps 以下。但大多数播放设备不支援播放任何版本的 AAC-HE 而只能播放 AAC-LC。 <a href="http://www.phpkoo.com/wp-content/uploads/2015/09/mobile01-0aaa64dadec533c578cc87c6c1054e16.png" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2015/09/mobile01-0aaa64dadec533c578cc87c6c1054e16.png" alt="mobile01-0aaa64dadec533c578cc87c6c1054e16"></a> x 轴为音质; y 轴为位元率 注意: AAC-HE v2 只能处理双声道。如果需要降混 (down-mix) 至 单声道，则使用 AAC-HE v1。 如果需要指定 Profile 则使用 -profile 选项。 Profiles: aac_low MPEG-4 AAC LC (default) aac_he MPEG-4 HE-AAC (SBR) aac_he_v2 MPEG-4 HE-AAC v2 (SBR+PS) aac_ld MPEG-4 AAC LD aac_eld MPEG-4 AAC ELD 例如: [shell] ffmpeg -i input.wav -ac 2 -c:a libfdk_aac -profile:a aac_he -vbr 3 output.m4a [/shell] <strong>Native FFmpeg AAC encoder</strong> 原生 (Native) FFmpeg AAC 编码器是已包含在 ffmpeg 内，而且它不像本文中其它 AAC 编码器那样需要一个外部程式库。注意这将不会让你得到如同 libfdk_aac 一样的良好结果。这被认为是实验性的编码器，所以需要 “-strict experimental” 或 “-strict -2 is”。 <strong>指定位元率</strong> 使用 -b 选项来指定输出位元率为 240kbps: [shell] ffmpeg -i input.wav -strict experimental -c:a aac -b:a 240k output.m4a [/shell] <strong>指定品质</strong> 使用 -q 选项来指定输出品质等级为 6: [shell] ffmpeg -i input.wav -strict experimental -c:a aac -q:a 6 output.m4a [/shell] 设定值有效范围为 0.1-10。比较高的设定值会得到较高的输出品质与位元率大小。 此 VBR 是实验性的并且有可能得到比 CBR 更差的结果。 <strong>libvo_aacenc</strong> VisualOn AAC 编码程式库。需要 ffmpeg 组态 (configuration) 中含有 –enable-libvo-aacenc。它有非 non-free 的优点，但它是一个更差的编码器比起 libfdk_aac 甚至 原生的 FFmpeg AAC 编码器，根据 FFmpeg AACの音质评価。此编码器最多只支援 2 声道，并只有 CBR 模式，而且不支援 VBR 输出。 <strong>CBR 128Kbps：</strong> [shell] ffmpeg -i input.wav -ac 2 -c:a libvo_aacenc -b:a 128k output.m4a [/shell] <strong>附：</strong></p>
<p>HE-AAC, HE-AAC v2<br>品质    高品质<br>比特率    HE-AAC：32至48kbit/s 单声道<br>        HE-AAC v2：16至24kbit/s 单声道<br>        高品质音频<br>采样率    24至96kHz<br>声道    单声道、立体声、多声道（如5.1、7.1）<br>应用    DVB（数 字视频广播）、ISDB（综合业务数字广播）、ARIB、ATSC-M/H、DAB+（数字音频广播）、DRM+（数字版权管理）、DRM、DVB- H（手持式数字视频广播）、DMB（数字多媒体广播）、MediaFLO、3GPP、XM广播、移动电话、音频和视频下载服务</p>
<p>AAC-LC<br>品质    达到统计学标准的清晰度<br>比特率    最高每通道256kbit/s<br>采样率    8至96kHz<br>声道    单声道、立体声、多声道（如5.1、7.1）<br>应用    苹果 iPod、 iTunes、QuickTime、 日本ISDB（综合业务数字广播）、 AV 接收器、汽车收音机、移动音乐播放器、移动电话</p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>aac</tag>
      </tags>
  </entry>
  <entry>
    <title>对FFmpeg的X264预置比较</title>
    <url>/posts/207.html</url>
    <content><![CDATA[<p>对FFmpeg的X264质量预设测量性能，要知道哪个选项是最适合我的目的将MPEG2 TS到苹果电视的MP4。因素需要考虑是： 1）转换的速度 2）文件的大小 3）视频的质量 最重要的因素就是转换的速度，如果时间转换比录制短。同时对于文件的大小也是越小越好。 测试方法 [shell] for i in ultrafast superfast veryfast faster fast medium slow slower veryslow placebo do ffmpeg -i sample.ts -vcodec libx264 \ -preset $i -profile:v baseline -level 3.0 -s 1280x720 \ -acodec libfaac -ab 160k \ -y $i.mp4 done [/shell] sample.ts是一个60秒的全高清（1440×1080），MPEG2视频 测试结果</p>
<p>preset used for conversion</p>
<p>Conversion speed (fps - frames per second) . The bigger the faster.</p>
<p>Size of the output video file (in bytes)</p>
<p>ultrafast</p>
<p>29.6</p>
<p>81,046,858</p>
<p>superfast</p>
<p>27.9</p>
<p>58,180,478</p>
<p>veryfast</p>
<p>20.6</p>
<p>43,968,615</p>
<p>faster</p>
<p>13.0</p>
<p>32,981,783</p>
<p>fast</p>
<p>9.1</p>
<p>35,461,071</p>
<p>medium</p>
<p>8.0</p>
<p>35,119,322</p>
<p>slow</p>
<p>5.6</p>
<p>33,367,247</p>
<p>slower</p>
<p>2.1</p>
<p>33,698,347</p>
<p>veryslow</p>
<p>1.3</p>
<p>29,697,663</p>
<p>placebo</p>
<p>0.6</p>
<p>29,395,288</p>
<p><a href="http://www.phpkoo.com/wp-content/uploads/2015/09/ffmpeg-presets-comparison-results.png" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2015/09/ffmpeg-presets-comparison-results.png" alt="ffmpeg-presets-comparison-results"></a></p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>x264</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装lua环境</title>
    <url>/posts/198.html</url>
    <content><![CDATA[<p>到LUA官网下载安装包 [shell] $ wget <a href="http://www.lua.org/ftp/lua-5.1.5.tar.gz" target="_blank" rel="noopener">http://www.lua.org/ftp/lua-5.1.5.tar.gz</a> $ tar zxvf lua-5.1.5.tar.gz $ cd lua-5.1.5/ $ yum install -y readline-devel ncurses-devel $ make linux [/shell] 如下提示： cd src &amp;&amp; make linux make[1]: Entering directory <code>/usr/local/src/lua-5.1.5/src&#39; make all MYCFLAGS=-DLUA\_USE\_LINUX MYLIBS=&quot;-Wl,-E -ldl -lreadline -lhistory -lncurses&quot; make\[2\]: Entering directory</code>/usr/local/src/lua-5.1.5/src’ make[2]: Nothing to be done for `all’. make[2]: Leaving directory `/usr/local/src/lua-5.1.5/src’ make[1]: Leaving directory `/usr/local/src/lua-5.1.5/src’ [shell] $ make install [/shell] cd src &amp;&amp; mkdir -p /usr/local/bin /usr/local/include /usr/local/lib /usr/local/man/man1 /usr/local/share/lua/5.1 /usr/local/lib/lua/5.1 cd src &amp;&amp; install -p -m 0755 lua luac /usr/local/bin cd src &amp;&amp; install -p -m 0644 lua.h luaconf.h lualib.h lauxlib.h ../etc/lua.hpp /usr/local/include cd src &amp;&amp; install -p -m 0644 liblua.a /usr/local/lib cd doc &amp;&amp; install -p -m 0644 lua.1 luac.1 /usr/local/man/man1 [shell] $ whereis lua lua: /usr/bin/lua /usr/lib64/lua /usr/local/bin/lua /usr/local/lib/lua /usr/share/lua /usr/share/man/man1/lua.1.gz $ /usr/local/bin/lua Lua 5.1.5 Copyright (C) 1994-2012 Lua.org, PUC-Rio [/shell] 安装完成。</p>
]]></content>
      <categories>
        <category>LUA</category>
      </categories>
      <tags>
        <tag>LUA</tag>
      </tags>
  </entry>
  <entry>
    <title>lua安装mongorover模块</title>
    <url>/posts/190.html</url>
    <content><![CDATA[<p>mongorover模块是mongodb官方提供的lua语言的驱动，官网API文档：<a href="http://api.mongodb.org/lua/0.1/index.html" target="_blank" rel="noopener">http://api.mongodb.org/lua/0.1/index.html</a> 通过luarocks方式安装lua模块 一、安装luarocks工具 [shell] $ wget <a href="http://luarocks.org/releases/luarocks-2.2.2.tar.gz" target="_blank" rel="noopener">http://luarocks.org/releases/luarocks-2.2.2.tar.gz</a> $ tar zxpf luarocks-2.2.2.tar.gz $ cd luarocks-2.2.2 $ ./configure $ make bootstrap [/shell] 二、安装mongorover模块 [shell] $ luarocks install mongorover [/shell] 安装时，报以下错误信息 Error: Could not find expected file libbson-1.0/bson.h, or libbson-1.0/bson.h for LIBMONGOC – you may have to install LIBMONGOC in your system and/or pass LIBMONGOC_DIR or LIBMONGOC_INCDIR to the luarocks command. Example: luarocks install mongorover LIBMONGOC_DIR=/usr/local 三、安装bson库 官方安装参照：<a href="http://api.mongodb.org/libbson/current/installing.html" target="_blank" rel="noopener">http://api.mongodb.org/libbson/current/installing.html</a> [shell] $ wget <a href="https://github.com/mongodb/libbson/releases/download/1.1.10/libbson-1.1.10.tar.gz" target="_blank" rel="noopener">https://github.com/mongodb/libbson/releases/download/1.1.10/libbson-1.1.10.tar.gz</a> $ tar -xzf libbson-1.1.10.tar.gz $ cd libbson-1.1.10/ $ ./configure $ make $ make install $ ln -s /usr/include/libbson-1.0/ /usr/local/libbson-1.0 [/shell] 再执行,安装mongorover模块,又报以下错误 Error: Could not find expected file libmongoc-1.0/mongoc.h, or libmongoc-1.0/mongoc.h for LIBMONGOC – you may have to install LIBMONGOC in your system and/or pass LIBMONGOC_DIR or LIBMONGOC_INCDIR to the luarocks command. Example: luarocks install mongorover LIBMONGOC_DIR=/usr/local 四、安装libmongoc库 官方安装参照：<a href="http://api.mongodb.org/c/current/installing.html" target="_blank" rel="noopener">http://api.mongodb.org/c/current/installing.html</a> [shell] $ wget <a href="https://github.com/mongodb/mongo-c-driver/releases/download/1.1.10/mongo-c-driver-1.1.10.tar.gz" target="_blank" rel="noopener">https://github.com/mongodb/mongo-c-driver/releases/download/1.1.10/mongo-c-driver-1.1.10.tar.gz</a> $ tar -xzf mongo-c-driver-1.1.10.tar.gz $ cd mongo-c-driver-1.1.10/ $ ./configure $ make $ make install $ ln -s /usr/include/libmongoc-1.0/ /usr/local/libmongoc-1.0 [/shell] 再执行,安装mongorover模块，安装成功</p>
]]></content>
      <categories>
        <category>LUA</category>
      </categories>
      <tags>
        <tag>LUA</tag>
        <tag>LUA-MongoDB模块</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下zeromq库安装</title>
    <url>/posts/180.html</url>
    <content><![CDATA[<p>zeromq是个类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而ZMQ屏蔽了这些细节，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。 <strong>安装</strong> ZeroMQ：<a href="http://download.zeromq.org/zeromq-4.1.3.tar.gz" target="_blank" rel="noopener">http://download.zeromq.org/zeromq-4.1.3.tar.gz</a> [shell] $ tar -xvzf zeromq-4.1.3.tar.gz $ cd zeromq-4.1.3 $ ./configure $ make $ make install [/shell] ./configure 提示 checking for sodium… no configure: error: Package requirements (libsodium) were not met ibsodium 是一个流行、易于使用的软件库。主要用于加密、解密、签名和生成密码哈希等等。这是一个可移植的、跨编译器支持、可安装的，基于 <a href="http://nacl.cr.yp.to/" target="_blank" rel="noopener">NaCl</a> 开发，提供一个兼容 API。它的目标是为所有构建更高级别的加密工具提供所需要的核心操作。 <strong>安装</strong> libsodium：<a href="https://github.com/jedisct1/libsodium/releases/download/1.0.3/libsodium-1.0.3.tar.gz" target="_blank" rel="noopener">https://github.com/jedisct1/libsodium/releases/download/1.0.3/libsodium-1.0.3.tar.gz</a> [shell] $ tar -xvzf libsodium-1.0.3.tar.gz $ cd libsodium-1.0.3 $ ./configure $ make $ make install [/shell] <strong>设置环境变量</strong> [shell] $ export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig [/shell] 最后ldconfig一下，更新一下动态链接库。 [shell] $ ldconfig [/shell] 再次安装ZeroMQ,安装成功。 同时需要将 [shell] $ yum remove zeromq $ yum remove zeromq-devel [/shell] 安装成功后，可安装nodejs或python等的zmq模块来验证一下刚安装的版本。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>zeroMQ</tag>
        <tag>zmq</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm 快速切换 Node 版本</title>
    <url>/posts/168.html</url>
    <content><![CDATA[<p>nvm 默认是从 <a href="http://nodejs.org/dist/" target="_blank" rel="noopener">http://nodejs.org/dist/</a> 下载的, 国外服务器, 必然很慢, 好在 nvm 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载 [shell] NVM_NODEJS_ORG_MIRROR=<a href="https://npm.taobao.org/dist" target="_blank" rel="noopener">https://npm.taobao.org/dist</a> nvm install 0.11.11 [/shell] 于是你就会看到一段非常快速进度条: [shell] ######################################################################## 100.0% Now using node v0.11.11 [/shell] 如果你不想每次都输入环境变量 NVM_NODEJS_ORG_MIRROR, 那么我建议你加入到 .bashrc 文件中: source [shell] export NVM_NODEJS_ORG_MIRROR=<a href="https://npm.taobao.org/dist" target="_blank" rel="noopener">https://npm.taobao.org/dist</a> source path/to/nvm/nvm.sh [/shell] 然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本: [shell] nvm ls nvm v0.8.26 v0.10.26 v0.11.11 -&gt; v0.11.12 [/shell] <strong>nrm 快速切换 NPM 源</strong> <strong>安装</strong> [shell] npm install -g nrm [/shell] <strong>使用</strong> 列出可选的源 [shell] nrm ls * npm —- <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a> cnpm — <a href="http://r.cnpmjs.org/" target="_blank" rel="noopener">http://r.cnpmjs.org/</a> taobao - <a href="http://registry.npm.taobao.org/" target="_blank" rel="noopener">http://registry.npm.taobao.org/</a> eu —– <a href="http://registry.npmjs.eu/" target="_blank" rel="noopener">http://registry.npmjs.eu/</a> au —– <a href="http://registry.npmjs.org.au/" target="_blank" rel="noopener">http://registry.npmjs.org.au/</a> sl —– <a href="http://npm.strongloop.com/" target="_blank" rel="noopener">http://npm.strongloop.com/</a> nj —– <a href="https://registry.nodejitsu.com/" target="_blank" rel="noopener">https://registry.nodejitsu.com/</a> [/shell] 带<em>的是当前使用的源，上面的输出表明当前源是官方源。 *</em>切换** 切换到taobao [shell] nrm use taobao [/shell] 增加源 你可以增加定制的源，特别适用于添加企业内部的私有源。 私有源可以使用cnpmjs架设 。 [shell] nrm add <registry> <url> [home] [/shell] 删除源 [shell] nrm del <registry> [/shell] 测试速度 你还可以通过 nrm test 测试相应源的响应时间。 例如，测试官方源的响应时间： [shell] nrm test npm npm —- 1328ms [/shell] 测试所有源的响应时间： [shell] nrm test npm —- 891ms cnpm — 1213ms * taobao - 460ms eu —– 3859ms au —– 1073ms sl —– 4150ms nj —– 8008ms [/shell] 注意，为了取得较准确的结果，可以考虑多次测试取平均值。 许可 nrm 为开源软件，使用 MIT 许可。 项目主页 <a href="http://github.com/Pana/nrm" target="_blank" rel="noopener">github.com/Pana/nrm</a></p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>node多版本管理</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>centos下安装nginx_lua_module模块</title>
    <url>/posts/157.html</url>
    <content><![CDATA[<p><a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua_module</a> 是一个nginx http模块，它把 lua 解析器内嵌到 nginx，用来解析并执行lua 语言编写的网页后台脚本。</p>
<p>特性：<br>支持Windows和Linux平台。<br>支持高并发高性能。<br>HTML网页中内嵌LUA脚本代码，类似于PHP。<br>支持非阻塞的数据库操作，目前只支持MYSQL。<br>支持异步的文件IO操作。<br>支持非阻塞的SOCKET IO操作。</p>
<p><strong>方式一：使用集成包安装</strong></p>
<p>下载 <a href="https://github.com/openresty/ngx_openresty" target="_blank" rel="noopener">ngx_openresty</a>，该集成包中有：Nginx，Lua或Luajit，ngx_lua，以及一些有用的Nginx第三方模块。</p>
<p>[shell] wget <a href="https://github.com/openresty/ngx_openresty" target="_blank" rel="noopener">https://github.com/openresty/ngx_openresty</a> ./configure –with-luajit make make install [/shell]</p>
<p><strong>方式二：Ngx_lua可以手动编译进Nginx(或Tengine)</strong></p>
<p>假定nginx的安装路径为：/usr/local/nginx</p>
<p>所需要的模块如下：<br><a href="https://github.com/openresty/luajit2" target="_blank" rel="noopener">luajit2</a> <a href="https://github.com/openresty/luajit2" target="_blank" rel="noopener">https://github.com/openresty/luajit2</a><br><a href="https://github.com/simpl/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a> <a href="https://github.com/simpl/ngx\_devel\_kit" target="_blank" rel="noopener">https://github.com/simpl/ngx\_devel\_kit</a><br><a href="https://github.com/agentzh/echo-nginx-module" target="_blank" rel="noopener">echo-nginx-module</a> <a href="https://github.com/agentzh/echo-nginx-module" target="_blank" rel="noopener">https://github.com/agentzh/echo-nginx-module</a><br><a href="https://github.com/chaoslawful/lua-nginx-module" target="_blank" rel="noopener">lua-nginx-module</a> <a href="https://github.com/chaoslawful/lua-nginx-module" target="_blank" rel="noopener">https://github.com/chaoslawful/lua-nginx-module</a></p>
<p>安装步骤：</p>
<p>1、安装openresty提供的luajit2</p>
<p>[shell] wget -O luajit2.zip <a href="https://codeload.github.com/openresty/luajit2/zip/v2.1-agentzh" target="_blank" rel="noopener">https://codeload.github.com/openresty/luajit2/zip/v2.1-agentzh</a> unzip luajit2.zip cd luajit2 make make install [/shell]</p>
<p>下面配置 luajit的环境变量(Nginx编译时需要)</p>
<p>[shell] export LUAJIT_LIB=/usr/local/lib export LUAJIT_INC=/usr/local/include/luajit-2.1 [/shell]</p>
<p>2、安装 ngx_devel_kit (NDK) 模块</p>
<p>[shell] wget -O ngx_devel_kit.zip <a href="https://codeload.github.com/simplresty/ngx\_devel\_kit/zip/master" target="_blank" rel="noopener">https://codeload.github.com/simplresty/ngx\_devel\_kit/zip/master</a> unzip ngx_devel_kit.zip -d /usr/local [/shell]</p>
<p>3、安装 lua-nginx-module 模块</p>
<p>[shell] wget -O lua-nginx-module.zip <a href="https://codeload.github.com/openresty/lua-nginx-module/zip/master" target="_blank" rel="noopener">https://codeload.github.com/openresty/lua-nginx-module/zip/master</a> unzip lua-nginx-module.zip -d /usr/local [/shell]</p>
<p>4、重新编译Nginx，需要注意编译顺序</p>
<p>[shell] ./configure –prefix=/usr/local/nginx \ –with-ld-opt=-Wl,-rpath,$LUAJIT_LIB \ –add-module=/usr/local/ngx_devel_kit \ –add-module=/usr/local/echo-nginx-module \ –add-module=/usr/local/lua-nginx-module make -j2 make install [/shell]</p>
<p><strong>注意：</strong>重新编译 Nginx 二进制，Nginx 需要 quit 再启动。而普通配置更新则 reload 即可。</p>
<p>[shell] #quit kill -HUP `cat /usr/local/nginx/logs/nginx.pid` #reload /usr/local/nginx/sbin/nginx -s reload [/shell]</p>
<p>模块编译完成！</p>
<p>在编译安装 Nginx 的第三方模块时，碰到一个错误：</p>
<p>[shell] /usr/local/nginx/sbin/ngxin -s reload /usr/local/nginx/sbin/nginx: error while loading shared libraries: libluajit-5.1.so.2: cannot open shared object file: No such file or directory [/shell]</p>
<p>解决办法。<br>在 Nginx 编译时，需要指定 RPATH，加入下面选项即可</p>
<p>[shell] ./configure –with-ld-opt=”-Wl,-rpath,$LUAJIT_LIB” 或者 export LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH [/shell]</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ngx_lua_module安装</tag>
        <tag>tengine</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装golang环境</title>
    <url>/posts/154.html</url>
    <content><![CDATA[<p>[shell] #在国内镜像下载二进制包 wget <a href="http://www.golangtc.com/static/go/go1.4.2.linux-amd64.tar.gz" target="_blank" rel="noopener">http://www.golangtc.com/static/go/go1.4.2.linux-amd64.tar.gz</a> #直接解压到目标目录即可 tar -C /usr/local -zxvf go1.4.2.linux-amd64.tar.gz #把golang的bin目录加入全局环境变量 cat &gt;&gt;/etc/profile&lt;&lt;EOF export PATH=$PATH:/usr/local/go/bin EOF #让配置生效 source /etc/profile #检查下是否成功 go version #在当前用户目录下新建go目录作为项目目录 mkdir -p $HOME/go #用cat的方法在尾部增加配置配置golang的 GOROOT GOPATH cat &gt;&gt;$HOME/.bash_profile&lt;&lt;EOF export GOROOT=/usr/local/go export GOPATH=\$HOME/go export GOBIN=\$HOME/go/bin export PATH=\$PATH:\$GOROOT/bin EOF #让配置生效 source $HOME/.bash_profile #检查下go的env环境变量 go env [/shell]</p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>go安装</tag>
      </tags>
  </entry>
  <entry>
    <title>python Image Library安装体验</title>
    <url>/posts/145.html</url>
    <content><![CDATA[<p>PIL是python理想的图片处理module，没安装该模块时会提示：ImportError: No module named Image，以下是PIL安装的依赖和步骤 我的环境：CentOS 6.5 / Python2.7 <strong>第一步：安装zlib png</strong> <strong>freetype</strong> **  jpeg** 安装zlib：<a href="http://zlib.net/zlib-1.2.8.tar.gz" target="_blank" rel="noopener">http://zlib.net/zlib-1.2.8.tar.gz</a> [shell] $ tar -xvzf zlib-1.2.8.tar.gz $ cd zlib-1.2.8 $ ./configure –prefix=/usr/local $ make $ make install [/shell] 安装png：<a href="ftp://ftp.simplesystems.org/pub/libpng/png/src/libpng15/libpng-1.5.23.tar.gz" target="_blank" rel="noopener">ftp://ftp.simplesystems.org/pub/libpng/png/src/libpng15/libpng-1.5.23.tar.gz</a> (如果文件不存在就浏览 /src/目录查找一下最新版) [shell] $ tar -xvzf libpng-1.5.23.tar.gz $ cd libpng-1.5.23 $ ./configure –prefix=/usr/local $ make $ make install [/shell] 安装freetype：<a href="http://nchc.dl.sourceforge.net/project/freetype/freetype2/2.4.7/freetype-2.4.7.tar.gz" target="_blank" rel="noopener">http://nchc.dl.sourceforge.net/project/freetype/freetype2/2.4.7/freetype-2.4.7.tar.gz</a> [shell] $ tar -xvzf freetype-2.4.7.tar.gz $ cd freetype-2.4.7/ $ ./configure –prefix=/usr/local $ make $ make install [/shell] 安装jpeg：<a href="http://www.ijg.org/files/jpegsrc.v8c.tar.gz" target="_blank" rel="noopener">http://www.ijg.org/files/jpegsrc.v8c.tar.gz</a> [shell] $ tar -xvzf jpegsrc.v8c.tar.gz $ cd jpeg-8c/ $ ./configure –prefix=/usr/local $ make $ make install [/shell] <strong>第二步：安装需要的 devel库（该步视情况可忽略）</strong> [shell] $ yum install libjpeg8-dev $ yum install libpng12-dev $ yum install libfreetype6-dev $ yum install zlib1g-dev [/shell] <strong>第三步：安装 PIL（ Python Imaging Library</strong> <strong>）</strong> 安装Image Library：<a href="http://effbot.org/downloads/Imaging-1.1.7.tar.gz" target="_blank" rel="noopener">http://effbot.org/downloads/Imaging-1.1.7.tar.gz</a> [shell] $ tar -xvzf Imaging-1.1.7.tar.gz $ cd Imaging-1.1.7/ #修改setup.py文件 vi setup.py #修改如下： JPEG_ROOT = “/usr/local/lib” ZLIB_ROOT = “/usr/local/lib” FREETYPE_ROOT = “/usr/local/lib” [/shell] 检查是否支持 [shell] $ python setup.py build_ext -i running build_ext ——————————————————————– PIL 1.1.7 SETUP SUMMARY ——————————————————————– version 1.1.7 platform linux2 2.7.8 (default, Sep 5 2014, 10:24:17) [GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] ——————————————————————– <strong>* TKINTER support not available — JPEG support available — ZLIB (PNG/ZIP) support available — FREETYPE2 support available *</strong> LITTLECMS support not available ——————————————————————– To add a missing option, make sure you have the required library, and set the corresponding ROOT variable in the setup.py script. To check the build, run the selftest.py script. [/shell] 开始安装Image Library [shell] $ python setup.py build $ python setup.py install [/shell] Python代码验证 [shell] $ python selftest.py *** The _imaging C module is not installed [/shell] ps: 运行python selftest.py提示The _imaging C module is not installed 解决方法，实际根据自己的python PIL路径设置 [shell] $ echo ‘/usr/local/lib/python2.7/site-packages/PIL’ &gt;&gt; /etc/ld.so.conf $ ldconfig [/shell] 重新python selftest.py，一路安装完成。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PIL</tag>
        <tag>py</tag>
      </tags>
  </entry>
  <entry>
    <title>node多版本管理</title>
    <url>/posts/142.html</url>
    <content><![CDATA[<p>nvm与Python的virtualenv和Ruby的rvm类似。 NVM (Node Version Manager，Node多版本管理器)是一个通用的叫法,它目前有许多不同的实现。通常我们说的 nvm 是指 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a> 或者 <a href="https://github.com/visionmedia/n" target="_blank" rel="noopener">https://github.com/visionmedia/n</a> 。这两个工具都是使用shell编写的。 <strong>n</strong> <strong>安装</strong> 如果已经安装了npm的话，可以直接执行命令进行安装n : [shell] $ npm install -g n [/shell] 或者是直接获取源代码安装： [shell] $ git clone <a href="https://github.com/visionmedia/n.git" target="_blank" rel="noopener">https://github.com/visionmedia/n.git</a> $ cd n $ make install [/shell]</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>直接运行 n 命令查看所有已安装的版本。 [shell] $ n [/shell] 运行命令 n 进行安装指定版本的node。 version 可以是 stable(最新稳定版)、latest(最新版)或者具体的版本数字。 [shell] $ n stable install : v0.10.24 mkdir : /usr/local/n/versions/0.10.24 fetch : <a href="http://nodejs.org/dist/v0.10.24/node-v0.10.24-linux-x64.tar.gz" target="_blank" rel="noopener">http://nodejs.org/dist/v0.10.24/node-v0.10.24-linux-x64.tar.gz</a> [/shell] 指定的版本将会安装在 /usr/local/n/versions 目录下。 运行命令 n rm 删除已安装指定版本的node。 运行命令 n use 选择使用指定版本的node。 <strong>nvm(推荐使用)</strong> <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>全称Node Version Manager，它与<code>n</code>的实现方式不同，其是通过shell脚本实现的。 <strong>安装</strong> 安装方式有两种： [shell] $ git clone <a href="https://github.com/creationix/nvm.git" target="_blank" rel="noopener">https://github.com/creationix/nvm.git</a> <del>/.nvm $ source ~/.nvm/nvm.sh [/shell] 或者 [shell] $ wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/master/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/creationix/nvm/master/install.sh</a> | sh $ source ~/.bash_profile [/shell] 以上脚本会把<code>nvm</code>库clone到`</del>/.nvm<code>，然后会在</code><del>/.bash_profile<code>,</code></del>/.zshrc<code>或``</code>~/.profile``末尾添加source，安装完成之后，你可以用以下命令来安装node <strong>使用</strong> 查看已安装的版本： [shell] $ nvm ls [/shell] 查看可以安装的版本： [shell] $ nvm ls-remote [/shell] 安装指定的版本： [shell] $ nvm install <version> [/shell]   指定的版本将会直接安装在 nvm 程序所在的目录下。 删除指定的版本： [shell] $ nvm uninstall <version> [/shell] 使用选定的版本： [shell] $ nvm use <version> [/shell]</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>多版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Zero downtime Node.js reloads with clusters</title>
    <url>/posts/120.html</url>
    <content><![CDATA[<p>Unlike PHP and other more traditional web applications, a Node.js server is just that–the server itself. Which means when we write a web application in Node.js, we’re creating a server application that is loaded into memory, and handles requests from there. If the source files change, the application does not, because it’s already been loaded into memory. In order to update the application with new code, the server has to be restarted. This becomes a little challenging when the goal is to run a server cleanly with no downtime. If we reboot the Node server, we kill all existing connections, have a period of downtime, and then a fresh instance starts, ready to handle connections. That’s not going to fly in production. There are ways to prevent this, though. <a href="https://github.com/LearnBoost/up" target="_blank" rel="noopener">Up</a>, for example, acts as a intermediate between your application and the request, which allows changes to be gracefully reloaded. It’s nice, but a little heavier than I’d like, and doesn’t play nicely with <a href="http://nodejs.org/api/cluster.html" target="_blank" rel="noopener">Node clusters</a>. Besides, I thought figuring out how to handle this myself would make a good learning experience. Fortunately, the cluster module has a <em>disconnect</em> event, which allows us to gracefully end the worker process. It will stop handling new requests, and the process will exit once the current requests are finished. That’s perfect. Here’s an example of what I cooked up. We’ll start with a separate app.js file; it’s important that the application code and clustering code be separate. app.js [js] var http = require(“http”);</code> http.createServer(function(req,rep) { rep.writeHead(200); rep.write(“Hello, world!”); rep.end(); }).listen(8080); [/js] This is our application. It can do whatever we want, but I’m keeping it simple for my testing purposes. Next, we need a master process to handle the clustering and worker respawns. runner.js [js] var cluster = require(“cluster”);</code> if (cluster.isMaster) { // this is the master control process console.log(“Control process running: PID=” + process.pid); // fork as many times as we have CPUs var numCPUs = require(“os”).cpus().length; for (var i = 0; i &lt; numCPUs; i++) { cluster.fork(); } // handle unwanted worker exits cluster.on(“exit”, function(worker, code) { if (code != 0) { console.log(“Worker crashed! Spawning a replacement.”); cluster.fork(); } }); // I’m using the SIGUSR2 signal to listen for reload requests // you could, instead, use file watcher logic, or anything else process.on(“SIGUSR2”, function() { console.log(“SIGUSR2 received, reloading workers”); // delete the cached module, so we can reload the app delete require.cache[require.resolve(“./app”)]; // only reload one worker at a time // otherwise, we’ll have a time when no request handlers are running var i = 0; var workers = Object.keys(cluster.workers); var f = function() { if (i == workers.length) return; console.log(“Killing “ + workers[i]); cluster.workers[workers[i]].disconnect(); cluster.workers[workers[i]].on(“disconnect”, function() { console.log(“Shutdown complete”); }); var newWorker = cluster.fork(); newWorker.on(“listening”, function() { console.log(“Replacement worker online.”); i++; f(); }); } f(); }); } else { var app = require(“./app”); } [/js] Make sense? I’ll break it down a little bit. We fork, per the <a href="http://nodejs.org/api/cluster.html" target="_blank" rel="noopener">cluster example</a>. In all the non-master threads (the forked children), we load our separate application. Then, if the master process receives a SIGUSR2 signal, we delete the cache of our application module, retrieve a list of active worker ids, and disconnect them one by one. We do this to ensure that there is never a situation where we go below the threshold of optimal worker threads, or worse, reach a point where no workers are running. We then load a replacement worker, and repeat the process until all of the old workers have been told to disconnect. It’s a little rough, but it works. To test it, I run the application server, and hit it with an apachebench with 100,000 requests at 1000 concurrency to check for failed requests. Beautiful. I can now integrate this into my post-update git hook for use in deployment.</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>graceful</tag>
        <tag>nodejs</tag>
        <tag>Zero downtime</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Ffmpeg获得flv视频缩略图和视频长度时间</title>
    <url>/posts/119.html</url>
    <content><![CDATA[<p>获得flv视频的缩略图和视频时间长度，php代码如下： [php] function BigEndian2Int($byte_word, $signed = false) { $int_value = 0; $byte_wordlen = strlen($byte_word); for ($i = 0; $i &lt; $byte_wordlen; $i++) { $int_value += ord($byte_word{$i}) * pow(256, ($byte_wordlen - 1 - $i)); } if ($signed) { $sign_mask_bit = 0x80 &lt;&lt; (8 * ($byte_wordlen - 1)); if ($int_value &amp; $sign_mask_bit) { $int_value = 0 - ($int_value &amp; ($sign_mask_bit - 1)); } } return $int_value; } //获得视频的数字时间 function getTime($name){ if(!file_exists($name)){ return; } $flv_data_length=filesize($name); $fp = @fopen($name, ‘rb’); $flv_header = fread($fp, 5); fseek($fp, 5, SEEK_SET); $frame_size_data_length =BigEndian2Int(fread($fp, 4)); $flv_header_frame_length = 9; if ($frame_size_data_length &gt; $flv_header_frame_length) { fseek($fp, $frame_size_data_length - $flv_header_frame_length, SEEK_CUR); } $duration = 0; while ((ftell($fp) + 1) &lt; $flv_data_length) { $this_tag_header = fread($fp, 16); $data_length = BigEndian2Int(substr($this_tag_header, 5, 3)); $timestamp = BigEndian2Int(substr($this_tag_header, 8, 3)); $next_offset = ftell($fp) - 1 + $data_length; if ($timestamp &gt; $duration) { $duration = $timestamp; } fseek($fp, $next_offset, SEEK_SET); } fclose($fp); return $duration; } //转化为0：03：56的时间格式 function fn($time){ $num = $time; $sec = intval($num/1000); $h = intval($sec/3600); $m = intval(($sec%3600)/60); $s = intval(($sec%60)); $tm = $h.’:’.$m.’:’.$s; return $tm; } $t = getTime(“22.flv”);//显示数字时间如236722 echo fn($t);//显示时间格式0:03:56 ?&gt; [/php]</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言的协程和通道通信</title>
    <url>/posts/117.html</url>
    <content><![CDATA[<p>许式伟的《go语言编程》，有一个简单的例子，描述go协程和通信通道chan。挺优美的。如下： [shell] [root@localhost test]$ cat sum.go package main import “fmt” func sum(values []int, myChan chan int) { sum := 0 for _, value := range values { sum += value } myChan &lt;- sum } func main() { myChan := make(chan int, 2) values := []int{1, 2, 3, 5, 5, 4} go sum(values, myChan) //协程1 go sum(values[:3], myChan) //协程2 sum1, sum2 := &lt;-myChan, &lt;-myChan fmt.Println(“Result:”, sum1, sum2, sum1+sum2) } 结果： [root@localhost test]$ go run sum.go Result: 6 20 26 [/shell]</p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN 无法通过windows installer服务安装此安装程序包</title>
    <url>/posts/116.html</url>
    <content><![CDATA[<p>xp sp3系统，当安装SVN客户端时出现问题 当安装 TortoiseSVN 1.8** 版本的时候 出现“无法通过 windows installer 服务安装此安装程序包。您必须安装带有更新版本 Windows Installer 服务的 Windows Service Pack ”提示如何解决？ 在网上搜集了好久，有好多人出现了同样的问题，所以记录下来 点击下载： <a href="http://www.microsoft.com/zh-cn/download/confirmation.aspx?id=8483" target="_blank" rel="noopener">http://www.microsoft.com/zh-cn/download/confirmation.aspx?id=8483</a> 下载补丁 WindowsXP-KB942288-v3-x86.exe ， 重启电脑就可以安装了</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>对zeroMQ的认识</title>
    <url>/posts/115.html</url>
    <content><![CDATA[<p>今天正式的去了理了下zmq这个传说是史上最快的消息队列，之前一直认为是个“服务”程序，是个类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系可以任意组合。上一段nodejs中使用zmq的官方例子 1、producer.js <code>[js] var zmq = require(&#39;zmq&#39;) , sock = zmq.socket(&#39;push&#39;);&lt;/code&gt; sock.bindSync(&#39;tcp://127.0.0.1:3000&#39;); console.log(&#39;Producer bound to port 3000&#39;); setInterval(function(){ console.log(&#39;sending work&#39;); sock.send(&#39;some work&#39;); }, 500); [/js] 2、worker.js `[js] var zmq = require(&#39;zmq&#39;) , sock = zmq.socket(&#39;pull&#39;);&lt;/code&gt; sock.connect(&#39;tcp://127.0.0.1:3000&#39;); console.log(&#39;Worker connected to port 3000&#39;); sock.on(&#39;message&#39;, function(msg){ console.log(&#39;work: %s&#39;, msg.toString()); }); [/js] 这样worker就开始工作了，接收到producer发送的数据`</code></p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>zeroMQ</tag>
        <tag>zmq</tag>
      </tags>
  </entry>
  <entry>
    <title>centos上安装php-memcached(v2.1.0)</title>
    <url>/posts/111.html</url>
    <content><![CDATA[<p>一、所需软件包  </p>
<p>[shell] wget <a href="https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz" target="_blank" rel="noopener">https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz</a> wget <a href="http://pecl.php.net/get/memcached-2.2.0.tgz" target="_blank" rel="noopener">http://pecl.php.net/get/memcached-2.2.0.tgz</a> [/shell]</p>
<p>二、解压  </p>
<p>[shell] tar xzf libmemcached-1.0.18.tar.gz tar xzf memcached-2.2.0.tgz [/shell]</p>
<p>三、GCC升级  </p>
<p>[shell] yum install gcc44 gcc44-c++ libstdc++44-devel export CC=/wp-content/bin/gcc44 export CXX=/wp-content/bin/g++44 [/shell]</p>
<p>提示：yum源更新命令yum update</p>
<p>四、libmemcached安装  </p>
<p>[shell] ./configure –prefix=/usr/local/libmemcached –with-memcached make &amp;&amp; make install [/shell]</p>
<p>五、memcached扩展安装  </p>
<p>[shell] /usr/local/php/bin/phpize</code> ./configure –with-php-config=/usr/local/php/bin/php-config –with-libmemcached-dir=/usr/local/libmemcached –enable-memcached-sasl make &amp;&amp; make install [/shell]</p>
<p>安装完成</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>libmemcached</tag>
        <tag>php-memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>如何运行一个golang程序为守护进程？</title>
    <url>/posts/109.html</url>
    <content><![CDATA[<p>安装daemonize 1、安装git环境 [shell] yum install git -y [/shell] 2、获取daemonize [shell] git clone git://github.com/bmc/daemonize.git [/shell] 3、安装daemonize [shell] cd daemonize ./configure make &amp;&amp; make install [/shell] 4、查看是否安装 [shell] daemonize -v [/shell] 通过daemonize执行golang守护进程 你需要打包你的golang程序为可执行文件（go build），并通过daemonize来执行它来实现守护进程，如： [shell] daemonize -p /var/run/myapp.pid -l /var/lock/subsys/myapp -u nobody /path/to/myapp [/shell]</p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>守护进程</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.3升级Python到2.7.3版本</title>
    <url>/posts/108.html</url>
    <content><![CDATA[<p>查看python的版本 [shell] python -V Python 2.6.6 [/shell] 1.下载Python-2.7.3 [shell] wget <a href="http://python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2" target="_blank" rel="noopener">http://python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2</a> [/shell] 2.解压Python-2.7.3 [shell] tar -jxvf Python-2.7.3.tar.bz2 [/shell] 3.进入刚解压后的文件夹(可使用命令) [shell] cd Python-2.7.3 [/shell] 4.安装 [shell] ./configure make all make install make clean make distclean [/shell] 5.查看版本信息 [shell] /wp-content/local/bin/python2.7 -V [/shell] 6.建立软连接，使系统默认的python指向python2.7 正常情况下即使python2.7安装成功后，系统默认指向的python仍然是2.6.6版本，考虑到yum是基于python2.6.6才能正常工作，不敢轻易卸载。 如何实现将系统默认的python指向到2.7版本呢？ [shell] mv /wp-content/bin/python /wp-content/bin/python2.6.6 ln -s /wp-content/local/bin/python2.7 /wp-content/bin/python [/shell] 检验python指向是否成功 [shell] python -V [/shell] 7.解决系统python软链接指向python2.7版本后，yum不能正常工作 [shell] vi /wp-content/bin/yum 将文件头部的 #!/wp-content/bin/python 改成 #!/wp-content/bin/python2.6.6 [/shell] 整个升级过程完成，可以使用Python2.7.3版本了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 测试硬盘读写速度</title>
    <url>/posts/107.html</url>
    <content><![CDATA[<p>time有计时作用，dd用于复制，从if读出，写到of。if=/dev/zero不产生IO，因此可以用来测试纯写速度。同理of=/dev/null不产生IO，可以用来测试纯读速度。bs是每次读或写的大小，即一个块的大小，count是读写块的数量。 1.测/目录所在磁盘的纯写速度： <code>[shell] dd if=/dev/zero of=1Gb.file bs=1k count=1000000&lt;/code&gt; time sh -c &quot;dd if=/dev/zero of=1Gb.file bs=1k count=1000000; sync&quot; [/shell] 2.测/目录所在磁盘的纯读速度： ``[shell] dd if=1Gb.file bs=64k |dd of=/dev/null&lt;/code&gt; time sh -c &quot;dd if=1Gb.file bs=64k |dd of=/dev/null; sync&quot; [/shell] 3.测读写速度： `[shell] dd if=1Gb.file of=2Gb.file bs=64k&lt;/code&gt; time sh -c &quot;dd if=1Gb.file of=2Gb.file bs=64k; sync&quot; [/shell]` ``</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
        <tag>测试硬盘读写</tag>
      </tags>
  </entry>
  <entry>
    <title>发布第一个github代码开源</title>
    <url>/posts/106.html</url>
    <content><![CDATA[<p>很久没写日志了，最近做一个公司项目，用到最近比较火的一门语言<a href="http://www.nodejs.org" target="_blank" rel="noopener">NodeJS</a>用该语言开发相关的功能，这里开源一个用nodejs写的mongodb库，闲话不多说，直接上项目地址。 项目地址：<a href="https://github.com/shideqin/mongodb-lib" target="_blank" rel="noopener">https://github.com/shideqin/mongodb-lib</a></p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>github</tag>
        <tag>mongodb</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>php中获取本周/本月的第一天的日期</title>
    <url>/posts/105.html</url>
    <content><![CDATA[<p><code>//本周第一天 function weekFirstDay($time=null) { $time = ($time==null) ? time() : $time; return date(&#39;Y-m-d&#39;, $time-86400*(date(&#39;N&#39;,$time)-1)); } //本月第一天 function monthFirstDay() { return date(&#39;Y-m-d&#39;, mktime(0,0,0,date(&#39;n&#39;),1,date(&#39;Y&#39;))); } //本季度第一天 function quarterFirstDay() { return date(&#39;Y-m-d&#39;, mktime(0,0,0,date(&#39;n&#39;)-(date(&#39;n&#39;)-1)%3,1,date(&#39;Y&#39;))); } //本年第一天 function yearFirstDay() { return date(&#39;Y&#39;).&#39;-01-01&#39;; }</code></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>date</tag>
        <tag>php</tag>
        <tag>时间</tag>
        <tag>本周</tag>
        <tag>本月</tag>
      </tags>
  </entry>
  <entry>
    <title>可代替VI及Nodepad++的产物</title>
    <url>/posts/104.html</url>
    <content><![CDATA[<p>Sublime Text 2 一款优化的代码开发工具，可算是一款小型的IDE工具，支持WIN,MAC,LINUX等操作系统，有丰富的工具包，可以通过Package管理工具进行各种扩展包安装，类似Eclipse中的Plug-in，同时该工具免费使用，无须支持免费当然偶尔会有付费提示，可不理会继续使用。 下载地址：<a href="http://www.sublimetext.com/" target="_blank" rel="noopener" title="http://www.sublimetext.com/">http://www.sublimetext.com/</a> 汉化语言包：<a href="http://download.csdn.net/detail/shisdq/4398263" target="_blank" rel="noopener" title="http://download.csdn.net/detail/shisdq/4398263">http://download.csdn.net/detail/shisdq/4398263</a> 注册补丁下载：<a href="http://download.csdn.net/detail/shisdq/4398223" target="_blank" rel="noopener" title="http://download.csdn.net/detail/shisdq/4398223">http://download.csdn.net/detail/shisdq/4398223</a> 注：文章中提供相关的工具，如有涉及到版权等相关问题均与作者无关，只做测试使用，禁止传播！</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>nodepad++</tag>
        <tag>Sublime Text 2</tag>
        <tag>text</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML中自定义属性,与自定义事件...</title>
    <url>/posts/103.html</url>
    <content><![CDATA[<p>此种技术一般使用在大型的UI系统开发中: 主要用于核心开发者了为了让 各类普通开发人员能方便调用自己的方法(事件).. 下面是相关示例: 核心开发者,负责拖动事件的JS书写.. 普通开发人员或者美工,只需制作HTML排版…并加上 核心开发者定义的自定义属性后,就能实现拖动. 微软IE中的document.attachEvent为我们提供了良好的自定义事件能力.. 本实例中的自定义属性为:eDrag 通过自定义属性来激活自定义事件.. `var <strong>DragId, __eDragSrc, __DragTop, __DragLeft; function __OnDrag(){ var _element = event.srcElement; if(_element.eDrag){ if(event.type==”mousedown”){ if(_element.eDragSrc){ __eDragSrc = document.getElementById(_element.eDragSrc); __eDragSrc.style.display = “block”; } document.body.style.cursor = “default”; __DragId = document.getElementById(_element.eDrag); __DragLeft = parseInt(</strong>DragId.offsetWidth)-(parseInt(<strong>DragId.offsetWidth)-(event.x-parseInt(</strong>DragId.offsetLeft))); <strong>DragTop = parseInt(</strong>DragId.offsetHeight)-(parseInt(<strong>DragId.offsetHeight)-(event.y-parseInt(</strong>DragId.offsetTop))); } if(event.type==”mouseup”){ if(<strong>DragId){ __DragId = null; } if(</strong>eDragSrc){ <strong>eDragSrc.style.display = “none”; __eDragSrc = null; } } } if(event.type==”mousemove”){ if(</strong>DragId){ __DragId.style.top = event.y - __DragTop; __DragId.style.left = event.x - __DragLeft; __DragId.style.margin = “auto”; } } } document.attachEvent(“onmousedown”, __OnDrag); document.attachEvent(“onmousemove”, __OnDrag); document.attachEvent(“onmouseup”, __OnDrag);</p>
<p>点击我来拖动表格</p>
<p>`</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>event</tag>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>2011九溪烧烤</title>
    <url>/posts/102.html</url>
    <content><![CDATA[<p>2011九溪烧烤</p>
]]></content>
      <categories>
        <category>本人唠叨</category>
      </categories>
      <tags>
        <tag>烧烤</tag>
      </tags>
  </entry>
  <entry>
    <title>那些相见恨晚的 JavaScript 技巧</title>
    <url>/posts/87.html</url>
    <content><![CDATA[<p>JavaScript 的成功让人津津乐道，为 Web 网页编写 JavaScript 代码已经是所有 Web 设计师的基本功，这门有趣的语言蕴藏着许多不为人熟知的东西，即使多年的 JavaScript 程序员，也未能完全吃透。本文从7个方面讲述 JavaScript 中那些你不很熟知但非常实用的技巧。 简略语句 JavaScript 可以使用简略语句快速创建对象和数组，比如下面的代码： <code>var car = new Object(); car.colour = &#39;red&#39;; car.wheels = 4; car.hubcaps = &#39;spinning&#39;; car.age = 4;</code> 可以使用简略语句如下： <code>var car = { colour:&#39;red&#39;, wheels:4, hubcaps:&#39;spinning&#39;, age:4 }</code> 对象 car 就此创建，不过需要特别注意，结束花括号前一定不要加 “;” 否则在 IE 会遇到很大麻烦。 创建数组的传统方法是： <code>var moviesThatNeedBetterWriters = new Array( &#39;Transformers&#39;,&#39;Transformers2&#39;,&#39;Avatar&#39;,&#39;Indiana Jones 4&#39; );</code> 使用简略语句则： <code>var moviesThatNeedBetterWriters = [ &#39;Transformers&#39;,&#39;Transformers2&#39;,&#39;Avatar&#39;,&#39;Indiana Jones 4&#39; ];</code> 另一个可以使用简略语句的地方是条件判断语句： <code>var direction; if(x &lt; 200){ direction = 1; } else { direction = -1; }</code> 可以简略为： <code>var direction = x &lt; 200 ? 1 : -1;</code> JSON 数据格式 JSON 是 “JavaScript Object Notation” 的缩写，由 Douglas Crockford 设计，JSON 改变了 JavaScript 在缓存复杂数据格式方面的困境，如下例，假如你要描述一个乐队，可以这样写： <code>var band = { &quot;name&quot;:&quot;The Red Hot Chili Peppers&quot;, &quot;members&quot;:[ { &quot;name&quot;:&quot;Anthony Kiedis&quot;, &quot;role&quot;:&quot;lead vocals&quot; }, { &quot;name&quot;:&quot;Michael &#39;Flea&#39; Balzary&quot;, &quot;role&quot;:&quot;bass guitar, trumpet, backing vocals&quot; }, { &quot;name&quot;:&quot;Chad Smith&quot;, &quot;role&quot;:&quot;drums,percussion&quot; }, { &quot;name&quot;:&quot;John Frusciante&quot;, &quot;role&quot;:&quot;Lead Guitar&quot; } ], &quot;year&quot;:&quot;2009&quot; }</code> 你可以在 JavaScript 中直接使用 JSON，甚至作为某些 API 的返回数据对象，以下代码调用著名书签网站 delicious.com 的一个 API，返回你在该网站的所有书签，并显示在你自己的网站：<code>function delicious(o){ var out = &#39;&lt;ul&gt;&#39;; for(var i=0;i&lt;o.length;i++){ out += &#39;&lt;li&gt;&lt;a href=&quot;&#39; + o[i].u + &#39;&quot;&gt;&#39; + o[i].d + &#39;&lt;/a&gt;&lt;/li&gt;&#39;; } out += &#39;&lt;/ul&gt;&#39;; document.getElementById(&#39;delicious&#39;).innerHTML = out; }</code> JavaScript 本地函数 (Math, Array 和 String) JavaScript 有很多内置函数，有效的使用，可以避免很多不必要的代码，比如，从一个数组中找出最大值，传统的方法是： <code>var numbers = [3,342,23,22,124]; var max = 0; for(var i=0;i max){ max = numbers[i]; } } alert(max);</code> 使用内置函数可以更容易实现： <code>var numbers = [3,342,23,22,124]; numbers.sort(function(a,b){return b - a}); alert(numbers[0]);</code> 另一个方法是使用 Math.max() 方法： <code>Math.max(12,123,3,2,433,4); // returns 433</code> 你可以用这个方法帮助探测浏览器 <code>var scrollTop= Math.max( doc.documentElement.scrollTop, doc.body.scrollTop );</code> 这解决了 IE 浏览器的一个问题，通过这种方法，你总是可以找到那个正确的值，因为浏览器不支持的那个值会返回 undefined。 还可以使用 JavaScript 内置的 split() 和 join() 函数处理 HTML 对象的 CSS 类名，如果 HTML 对象的类名是空格隔开的多个名字，你在为它追加或删除一个 CSS 类名的时候需要特别注意，如果该对象还没有类名属性，可以直接将新的类名赋予它，如果已经存在类名，新增的类名前必须有一个空格，用传统的 JavaScript 方法是这样实现的： <code>function addclass(elm,newclass){ var c = elm.className; elm.className = (c === &#39;&#39;) ? newclass : c+&#39; &#39;+newclass; }</code> 使用 split 和 join 方法则直观优雅得多： <code>function addclass(elm,newclass){ var classes = elm.className.split(&#39; &#39;); classes.push(newclass); elm.className = classes.join(&#39; &#39;); }</code> 事件代理 与其在 HTML 文档中设计一堆事件，不如直接设计一个事件代理，举例说明，假如你有一些链接，用户点击后不想打开链接，而是执行某个事件，HTML 代码如下：`</p>
<h2 id="Great-Web-resources"><a href="#Great-Web-resources" class="headerlink" title="Great Web resources"></a>Great Web resources</h2><ul>
<li><a href="http://opera.com/wsc" target="_blank" rel="noopener">Opera Web Standards Curriculum</a></li>
<li><a href="http://sitepoint.com" target="_blank" rel="noopener">Sitepoint</a></li>
<li><a href="http://alistapart.com" target="_blank" rel="noopener">A List Apart</a></li>
<li><a href="http://yuiblog.com" target="_blank" rel="noopener">YUI Blog</a></li>
<li><a href="http://blameitonthevoices.com" target="_blank" rel="noopener">Blame it on the voices</a></li>
<li><a href="http://oddlyspecific.com" target="_blank" rel="noopener">Oddly specific</a></li>
</ul>
<p><code>传统的事件处理是遍历各个链接，加上各自的事件处理： ``// Classic event handling example (function(){ var resources = document.getElementById(&#39;resources&#39;); var links = resources.getElementsByTagName(&#39;a&#39;); var all = links.length; for(var i=0;i 使用事件代理，可以直接处理，无需遍历：</code>(function(){ var resources = document.getElementById(‘resources’); resources.addEventListener(‘click’,handler,false); function handler(e){ var x = e.target; // get the link tha if(x.nodeName.toLowerCase() === ‘a’){ alert(‘Event delegation:’ + x); e.preventDefault(); } }; })();<code>匿名函数与 Module 模式 JavaScript 的一个问题是，任何变量，函数或是对象，除非是在某个函数内部定义，否则，就是全局的，意味着同一网页的别的代码可以访问并改写这个变量（ECMA 的 JavaScript 5 已经改变了这一状况 - 译者），使用匿名函数，你可以绕过这一问题。 比如，你有这样一段代码，很显然，变量 name, age, status 将成为全局变量</code>var name = ‘Chris’; var age = ‘34’; var status = ‘single’; function createMember(){ // […] } function getMemberDetails(){ // […] }<code>为了避免这一问题，你可以使用匿名函数：</code>var myApplication = function(){ var name = ‘Chris’; var age = ‘34’; var status = ‘single’; function createMember(){ // […] } function getMemberDetails(){ // […] } }();<code>如果这个函数不会被调用，可以更直接为：</code>(function(){ var name = ‘Chris’; var age = ‘34’; var status = ‘single’; function createMember(){ // […] } function getMemberDetails(){ // […] } })();<code>如果要访问其中的对象或函数，可以：</code>var myApplication = function(){ var name = ‘Chris’; var age = ‘34’; var status = ‘single’; return{ createMember:function(){ // […] }, getMemberDetails:function(){ // […] } } }(); // myApplication.createMember() and // myApplication.getMemberDetails() now works.<code>这就是所谓 Module 模式或单例模式（Singleton），该模式为 Douglas Crockford 所推崇，并被大量应用在 Yahoo User Interface Library YUI。 假如你想在别的地方调用里面的方法，又不想在调用前使用 myApplication 这个对象名，可以在匿名函数中返回这些方法，甚至用简称返回：</code>var myApplication = function(){ var name = ‘Chris’; var age = ‘34’; var status = ‘single’; function createMember(){ // […] } function getMemberDetails(){ // […] } return{ create:createMember, get:getMemberDetails } }(); //myApplication.get() and myApplication.create() now work.` 代码配置 别人使用你编写的 JavaScript 代码的时候，难免会更改某些代码，但这会很困难，因为不是每个人都很容易读懂别人的代码，与其这样，不如创建一个代码配置对象，别人只需要在这个对象中更改某些配置即可实现代码的更改。这里有一篇 JavaScript 配置对象详解的文章，简单说： 在代码中创建一个叫做 configuration 的对象 里面保存所有可以更改的配置，如 CSS ID 和类名，按钮的标签文字，描述性文字，本地化语言设置 将该对象设置为全局对象，以便别人直接访问并改写 你应当在最后一步做这项工作，这里有一个文章，交付代码前的5件事值的参考。 同后台交互 JavaScript 是一门前台语言，你需要别的语言同后台交互，并返回数据，使用 AJAX，你可以让 JavaScript 直接使用同后台的交互，将复杂的数据处理交由后台处理。 JavaScript 框架 自己编写适应各种浏览器的代码是完全浪费时间，应当选择一个 JavaScript 框架，让这些复杂的事情交给框架处理。``</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>计算php运行时间（毫秒数）</title>
    <url>/posts/86.html</url>
    <content><![CDATA[<p>非常简单，记录一下： <code>$begin= explode(&#39; &#39;, microtime()); //php script here $end = explode(&#39; &#39;, microtime()); echo ($end[1]-$begin[1]).&#39;s&#39;.($end[0]-$begin[0]).&#39;ms&#39;;</code></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>microtime()</tag>
        <tag>毫秒</tag>
      </tags>
  </entry>
  <entry>
    <title>通过PATH_INFO的方式来实现搜索引擎友好 隐藏index.php</title>
    <url>/posts/85.html</url>
    <content><![CDATA[<p>我习惯使用PATH_INFO的方式来实现搜索引擎友好，比如： 　　<a href="http://www.xxx.com/index.php/module/xxx/action/xxx/id/xxx" target="_blank" rel="noopener">http://www.xxx.com/index.php/module/xxx/action/xxx/id/xxx</a> 　　但是index.php能看到扩展名很不爽，解决方法如下： 　　如何隐蔽应用：例如 .php，的扩展名： 　　在APACHE中这样配置： 　　ForceType application/x-httpd-php 　　如何更像静态页面：app_name/my/app.html 　　解析的PATH_INFO参数的时候，把最后一个参数的最后5个字符“.html”截断即可。 　　注意：APACHE2中缺省是不允许PATH_INFO的，需要设置 AcceptPathInfo on 　　<a href="http://www.xxx.com/index/module/xxx/action/xxx/id/xxx" target="_blank" rel="noopener">http://www.xxx.com/index/module/xxx/action/xxx/id/xxx</a></p>
]]></content>
      <categories>
        <category>Apache</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>path_info</tag>
        <tag>rewrite</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>小型关系型数据库 SQLite 3.7.3发布</title>
    <url>/posts/84.html</url>
    <content><![CDATA[<p>SQLite是遵守ACID的关联式数据库管理系统，它包含在一个相对小的C库中。它是D.RichardHipp建立的公有领域项目。 　　该版本增加了 sqlite3_create_function_v2() 接口，用以处理析构器(destructor)的回调;通过使用应用提供的回调函数来定义查询区域的边界以增加对自定义 r-tree 查询;默认的页缓存努力避免内存分配大于预设SQLITE_CONFIG_PAGECACHE的值等。 下载地址:<a href="http://www.sqlite.org/download.html" target="_blank" rel="noopener">http://www.sqlite.org/download.html</a></p>
]]></content>
      <categories>
        <category>PHP</category>
        <category>数据库篇</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>sql</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>Win下PHP支持Sqlite</title>
    <url>/posts/82.html</url>
    <content><![CDATA[<p>SQLite 是个使用档案方式存储的 Database,不需要另外安装如 MySQL 之类的 Server,而且 PHP 5 已经將 SQLite 內建了,相当好用,在某些方面效能比起其他 Database 系统有过之而无不及.目前国內很少人知道. SQLite 在 windows 的安裝方式: PHP 4 版本 1.下載 php_sqlite.dll(注意版本号),复制到 php/exetensions/ 下 2.php.ini 加上 extension=php_sqlite.dll 3.重新启动 Web Server 即可 PHP 5 版本 PHP 5 已经包含 SQLite 模组了,所以只需要载入模组即可 修改 php.ini 找到 ;extension=php_sqlite.dll 将前面的分号去掉 目前测试结果在 PHP 5.1.1 和 5.1.2 只有这样是运行不起來的,必須连 pdo 一起启动,所以在前 面增加兩行: <code>extension=php_pdo.dll extension=php_pdo_sqlite.dll extension=php_sqlite.dll</code> 重新启动 Web Server 即可 注明:PHP Version 5.1.6也有这样的问题.</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php_sqlite.dll</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 中 error_reporting(0) 详解</title>
    <url>/posts/81.html</url>
    <content><![CDATA[<p>error_reporting(255); 是列出所以提示 error_reporting(0); 是不显示所以提示 建议使用 error_reporting(7); 只显示严重错误，显示1，2，4 错误 1 E_ERROR 致命的运行时错误 2 E_WARNING 运行时警告(非致命性错误) 4 E_PARSE 编译时解析错误 8 E_NOTICE 运行时提醒(经常是bug，也可能是有意的) 16 E_CORE_ERROR PHP启动时初始化过程中的致命错误 32 E_CORE_WARNING PHP启动时初始化过程中的警告(非致命性错) 64 E_COMPILE_ERROR 编译时致命性错 128 E_COMPILE_WARNING 编译时警告(非致命性错) 256 E_USER_ERROR 用户自定义的致命错误 512 E_USER_WARNING 用户自定义的警告(非致命性错误) 1024 E_USER_NOTICE 用户自定义的提醒(经常是bug，也可能是有意的) 2048 E_STRICT 编码标准化警告(建议如何修改以向前兼容) 4096 E_RECOVERABLE_ERROR 接近致命的运行时错误，若未被捕获则视同E_ERROR 6143 E_ALL 除E_STRICT外的所有错误(PHP6中为8191,即包含所有)</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>error_reporting</tag>
        <tag>错误详解</tag>
      </tags>
  </entry>
  <entry>
    <title>php利用header函数实现文件下载时直接提示保存</title>
    <url>/posts/78.html</url>
    <content><![CDATA[<p>下面是网上常用的方法 <code>if (isset($link)) { Header(&quot;HTTP/1.1 303 See Other&quot;); Header(&quot;Location: $link&quot;); exit; }</code> <strong>注：</strong> http响应码 http响应码的分布从1xx ~ 5xx, 比较熟悉的有200(OK), 500 (Internal Server Error), 503 (Service Unavailable)等。 3xx系列的响应码表示“重定向” (Redirection)， 这里特别分析303 (See Other)，303的rfc2616说明有几点值得我们注意： 服务器在返回303的同时，应该(SHOULD)返回一个不同的URI，并放到Location字段中。 客户端收到303后，可以使用这个URI获取新的资源（必须使用GET获取新资源） 303的响应不能被缓存，但是Get到的新资源是可以被缓存的</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>303</tag>
        <tag>header</tag>
        <tag>HTTP</tag>
        <tag>文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL大数据导出、导入</title>
    <url>/posts/75.html</url>
    <content><![CDATA[<p>使用MYSQL导入文本内容 使用LOAD DATA INFILE命令 例如：load data infile ‘date.dat’ into table test fields terminated by ‘,’; 具体load data infile命令使用及参数请参考MYSQL手册 注：使用MYSQL导出数据写入文本方法如下： select * into outfile ‘data.txt’ fields terminated by ‘,’ from test ;</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>load data</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP加密扩展库——Mcrypt扩展库</title>
    <url>/posts/74.html</url>
    <content><![CDATA[<p>PHP除了自带的几种加密函数外，还有功能更全面的加密扩展库Mcrypt和Mhash。其中，Mcrypt扩展库可以实现加密解密功能，就是既能将明文加密，也可以密文还原。 1.Mcrypt库安装 在标准的PHP安装过程中并没有把Mrcypt安装上，但PHP的主目录下包含了libmcrypt.dll和libmhash.dll文件(libmhash.dll是Mhash扩展库，这里可以一起装上)。首先，将这两个文件复制到系统目录windows\system32下，然后在PHP.ini文件中按Ctrl+F快捷键跳出查找框，并找到；extension=php-mcrypt.dll和;extension=php_mhash.dll这两个语句，接着将前面的“；”去掉；最后，保存并重启Apache服务器即可生效。 2.Mcrypt库的算法和加密模式 Mcrypt库支持20多种加密算法和8种加密模式，具体可以通过函数mcrypt_list_algorithms()和mcrypt_list_modes()来显示，结果如下： Mcrypt支持的算法有：cast-128 gost rijndael-128 twofish arcfour cast-256 loki97 rijndael-192 saferplus wake blowfish-compat des rijndael-256 serpent xtea blowfish enigma rc2 tripledes Mcrypt支持的加密模式有：cbc cfb ctr ecb ncfb nofb ofb stream 这些算法和模式在应用中要以常量来表示，写的时候加上前缀MCRYPT_和MCRYPT_来表示，如下面Mcrypt应用的例子： DES算法表示为MCRYPT_DES; ECB模式表示为MCRYPT_MODE_ECB； 3.Mcrypt应用 先看一个例子，了解Mcrypt的工作流程，再来看看部分流程使用的函数： <code>&quot;; $str_encrypt = mcrypt_encrypt($cipher,$key,$str,$modes,$iv);//加密函数 echo &quot;加密密文：&quot;.$str_encrypt.&quot;</code></p>
<p><code>&quot;; $str_decrypt = mcrypt_decrypt($cipher,$key,$str_encrypt,$modes,$iv);//解密函数 echo &quot;还原：&quot;.$str_decrypt; ?&gt;</code>运行结果： 加密明文：我的名字是？一般人我不告诉他！ 加密密文： 锍盌?]鸴?q攦軄L 笑 郺葄”簻 黙 还原：我的名字是？一般人我不告诉他！ &lt;1&gt;由例子中可看到，使用Mcrypt对数据加密和解密之前，首先创建了一个初始化向量，简称为iv。由$iv = mcrypt_create_iv(mcrypt_get_iv_size($cipher,$modes),MCRYPT_RAND);可见创建初始化向量需要两个参数：size指定了iv的大小；source为iv的源，其中值MCRYPT_RAND为系统随机数。 &lt;2&gt;函数mcrypt_get_iv_size($cipher,$modes)返回初始化向量大小，参数cipher和mode分别指算法和加密模式。 &lt;3&gt;加密函数$str_encrypt = mcrypt_encrypt($cipher,$key,$str,$modes,$iv); 该函数的5个参数分别如下：cipher——加密算法、key——密钥、data(str)——需要加密的数据、mode——算法模式、iv——初始化向量 &lt;4&gt;解密函数mcrypt_decrypt($cipher,$key,$str_encrypt,$modes,$iv); 该函数和加密函数的参数几乎一样，唯一不同的是data，也就是说data为需要解密的数据$str_encrypt，而不是原始数据$str。 注：加密和解密函数中的参数cipher、key和mode必须一一对应，否则数据不能被还原。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mcrypt</tag>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title>通过file_get_contents来Post数据的实例[转载]</title>
    <url>/posts/73.html</url>
    <content><![CDATA[<p>原文： file_get_contents.php: Post数据 <code>&#39;POST&#39;, &#39;content&#39; =&gt; http_build_query($post, &#39;&#39;, &#39;&amp;&#39;), ); } return file_get_contents($url, false, stream_context_create($context)); } $data = array ( &#39;name&#39; =&gt; &#39;test&#39;, &#39;email&#39; =&gt; &#39;test@gmail.com&#39;, &#39;submit&#39; =&gt; &#39;submit&#39;, ); echo Post(&#39;http://localhost/5-5/request_post_result.php&#39;, $data); ?&gt;</code> 接收数据： request_post_result.php 接收经过Post的数据： 看一下，里面有一个特别的函数：stream_context_create，翻开手册看了一下，也没说什么呀，只是说：Creates and returns a stream context with any options supplied in options preset. 而file_get_contents呢？它说： Note: Context support was added with PHP 5.0.0. For a description of contexts, refer to Reference CLX, Stream Functions. 关于Stream Functions，手册上这么描述的。。。 A wrapper is additional code which tells the stream how to handle specific protocols/encodings. For example, the http wrapper knows how to translate a URL into an HTTP/1.0 request for a file on a remote server. There are many wrappers built into PHP by default (See Appendix O), and additional, custom wrappers may be added either within a PHP script using stream_wrapper_register(), or directly from an extension using the API Reference in Chapter 52. Because any variety of wrapper may be added to PHP, there is no set limit on what can be done with them. To access the list of currently registered wrappers, use stream_get_wrappers(). A stream is referenced as: scheme://target scheme(string) - The name of the wrapper to be used. Examples include: file, http, https, ftp, ftps, compress.zlib, compress.bz2, and php. See Appendix O for a list of PHP built-in wrappers. If no wrapper is specified, the function default is used (typically file://). target - Depends on the wrapper used. For filesystem related streams this is typically a path and filename of the desired file. For network related streams this is typically a hostname, often with a path appended. Again, see Appendix O for a description of targets for built-in streams.</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>file_get_contents</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PHP发送邮件 mail() OR socket</title>
    <url>/posts/72.html</url>
    <content><![CDATA[<p>使用php发送邮件主要有两种方式： 1.使用mail函数发送 2.通过Socket方式发送 <strong>1. mail()函数发送邮件</strong> mail()函数目前不支持远程smtp的验证，如果使用此方式，本地服务器需要支持smtp服务，windows系统下可以通过安装IIS组件里的“SMTP Service”来配置smtp服务器环境，linux系统下可以通过安装其它mail组件系统来配置smtp服务。服务器环境配置好以后，下面看一下使用方法。 <code>mail(to,subject,message,headers,parameters)</code> 简单实例： <strong>2.使用Socket方式发送邮件</strong> 使用Socket方式，可以利用远程smtp服务器发送邮件，Socket支持远程smtp验证，所以这也是Socket方式一个比较灵活的地方，如果本地服务器不支持smtp，使用mail()函数会出错，此时可以考虑使用Socket方式发送邮件，目前网上有比较多的Socket发送邮件类的源码，可以参考一下。 使用Socket的第一步，需要你有一个可用的邮箱(126或163都可以，当然其它的也行)。 网上的部分参考代码： <code>&quot;.$lb,&quot;250&quot;,&quot;MAIL FROM error: &quot;); //6、发送Rcpt To。期待返回250 $smtp[] = array(&quot;RCPT TO: &lt;&quot;.$to.&quot;&gt;&quot;.$lb,&quot;250&quot;,&quot;RCPT TO error: &quot;); //7、发送DATA，期待返回354 $smtp[] = array(&quot;DATA&quot;.$lb,&quot;354&quot;,&quot;DATA error: &quot;); //8.0、发送From $smtp[] = array(&quot;From: =?&quot;.$charset.&quot;?B?&quot;.base64_encode($send_name).&quot;?=&quot;.$lb.&quot; &lt;&quot;.$send_addr.&quot;&gt;&quot;.$lb,&quot;&quot;,&quot;&quot;); //8.2、发送To $smtp[] = array(&quot;To: &quot;.$to.$lb,&quot;&quot;,&quot;&quot;); //8.1、发送标题 $smtp[] = array(&quot;Subject: &quot;.$subject.$lb,&quot;&quot;,&quot;&quot;); //8.3、发送其他Header内容 $smtp[] = array($header.$lb,&quot;&quot;,&quot;&quot;); //8.4、发送一个空行，结束Header发送 $smtp[] = array($lb,&quot;&quot;,&quot;&quot;); //8.5、发送信件主体 $smtp[] = array(base64_encode($body.$lb).$lb,&quot;&quot;,&quot;&quot;); //9、发送“.”表示信件结束，期待返回250 $smtp[] = array(&quot;.&quot;.$lb,&quot;250&quot;,&quot;DATA(end)error: &quot;); //10、发送Quit，退出，期待返回221 $smtp[] = array(&quot;QUIT&quot;.$lb,&quot;221&quot;,&quot;QUIT error: &quot;); //打开smtp服务器端口 $fp=@fsockopen($smtp_host, $smtp_port); if(!$fp) echo &quot;**Error:** Cannot conect to &quot;.$smtp_host.&quot;  
&quot;; while($result = @fgets($fp, 1024)){ if(substr($result,3,1) == &quot; &quot;) { break; } } $result_str=&quot;&quot;; //发送smtp数组中的命令/数据 foreach($smtp as $req){ //发送信息 @fwrite($fp, $req[0]); //如果需要接收服务器返回信息，则 if($req[1]){ //接收信息 while($result = @fgets($fp, 1024)){ if(substr($result,3,1) == &quot; &quot;) { break; } } if (!strstr($req[1],substr($result,0,3))){ $result_str.=$req[2].$result.&quot;  
&quot;; } } } //关闭连接 @fclose($fp); return $result_str; } ?&gt;</code> 使用方法： <code>&quot;; } else{ echo &quot;发送失败！  
&quot;; } ?&gt;</code> 源码下载：<a href="http://www.phpkoo.com/blog/wp-content/uploads/2010/08/3664070170.zip" target="_blank" rel="noopener" title="mail.class.zip">mail.class.zip</a></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mail</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonic八荣八耻</title>
    <url>/posts/71.html</url>
    <content><![CDATA[<p><strong>Pythonic八荣八耻</strong> 以动手实践为荣 , 以只看不练为耻; 以打印日志为荣 , 以单步跟踪为耻; 以空格缩进为荣 , 以制表缩进为耻; 以单元测试为荣 , 以人工测试为耻; 以模块复用为荣 , 以复制粘贴为耻; 以多态应用为荣 , 以分支判断为耻; 以Pythonic为荣 , 以冗余拖沓为耻; 以总结分享为荣 , 以跪求其解为耻;</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pythonic</tag>
        <tag>八荣八耻</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL 复制表结构及数据</title>
    <url>/posts/70.html</url>
    <content><![CDATA[<p>第一种，适合复制表结构，但不会复制表内容 <code>CREATE TABLE table_name LIKE table_name2</code> 第二种，适合复制表内容，但也会复制表结构(与第一种相比会少一些原始表参数) <code>CREATE TABLE table_name LIKE table_name2</code></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sdq</tag>
        <tag>复制表结构及数据</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP5.3的新特性</title>
    <url>/posts/69.html</url>
    <content><![CDATA[<p>本文主要说说PHP V5.3 的以下特性： * 延迟静态绑定 * 名称空间 * 类方法重载 * 变量解析和 heredoc <strong>延迟静态绑定</strong> PHP V5.3 扩展了 static 关键词的使用。现在，无需实例化类便可访问静态类方法和属性。当类不存在对象，或者不需要对象时，这个特性就比较方便。下面就是展示了延迟静态绑定的一个例子。 以上会产生这样的输出： <code>Calling who method from class B</code> 在 PHP V5.3.0 之前，类 A 中的方法可能被定义为 self::who()。不幸的是，这将导致调用类 A 中的函数，而不是子类 B 中的函数。PHP V5.3.0 用 static:: 关键词修复了这个问题，允许在运行时才引用之前调用的类方法。显然这就是这段代码的目的。 <code>增强面向对象 任何能增强 PHP 面向对象方面的改变都是受鼓励的，因为这将导致更可靠的设计和更易于维护的代码。对于上面的代码我有些许微词，基类（A）和派生类（B）中的 who() 方法是重复的。如果类 B 中不必复制该代码就好了，但是似乎 PHP V5.3.0 中的 __CLASS__ 语法要求必须这么做。也就是说，__CLASS__ 不支持延迟绑定。 代码中使用 __CLASS__ 也许有点勉强，但确实可以说明 PHP V5.3.0 有一个小小的问题。显然，对于这个例子，这不是多大的问题，但是对于有数千行 PHP 代码的网站来说，就没那么简单了。重复代码通常意味着重复劳动。</code> <strong>名称空间（也有叫命名空间的）</strong> PHP V5.3 提供名称空间功能，以增强该语言的封装能力。名称空间在现代语言中非常常见，例如 C# 和 XML。名称空间的主要优点是，通过它可以为代码符号（类、函数和常量）定义独立的容器，这听起来有点复杂，其实不然。以下代码显示了使用 PHP 名称空间定义本地和全局字符串常量的一个例子。 `My string is: “; echo ASTRING; echo “</p>
<p>“; echo “</p>
<p>My string is “; echo \ASTRING; echo “</p>
<p>“; ?&gt;<code></code>My string is: Hello World from my namespace! My string is: Hello World!<code>那么，代码中发生了什么？第一个 define 语句在名称空间 test 中创建一个字符串常量 ASTRING。然后，当引用 ASTRING 字符串时，引擎首先查看本地 test 名称空间。这就是为什么看到本地定义的字符串首先显示。然后，要看到全局定义的字符串，只需使用语法 \\ASTRING。有了这些简单的规则，便可以使用任意数量的名称空间，而不必担心名称冲突。 有了名称空间功能，和之前相比，代码之间的界限更加清晰。而这一点又有助于团队环境中的代码整合。换句话说，不同的团队可以分配他们自己的名称空间，当所有团队成员都遵循这个惯例时，名称冲突的情况应该会降为零。这也是 5.3.0 版对 PHP 语言在面向对象方面的一个增强。 **类方法重载** 在 PHP 中，术语重载（overloading） 与通常的面向对象上下文稍有不同。在 Java 语言或 C# 中，“重载” 方法是指为不同参数列表提供相同代码的方法。例如，如果有一个名为 draw(String str) 的方法，那么重载的方法可以有以下形式：draw(String str, int i)。这种方法符号名称被称作方法签名，为了便于重载，返回类型被省略。 在 PHP 中，“重载” 是指动态创建的方法和属性。这实际上是动态代码，任何这样的动态实体都是由所谓的魔术方法（magic methods） 来处理。可以在一个类中为各种不同的动作创建这些魔术方法。然后，当代码中遇到未声明或不可见的属性或方法时，便可以调用重载方法。这样风格的重载提供了很大程度上的灵活性。 听起来有些复杂，所以来看看一个具体的例子。以下代码展示如何使用 PHP 重载调用对象和类方法。</code>runOverloadedTest(‘in an object context’); OverloadedMethodTest::runOverloadedTest(‘in a static context’); // As of PHP 5.3.0 ?&gt;<code></code>Calling object method ‘runOverloadedTest’ in an object context Calling static method ‘runOverloadedTest’ in a static context<code>注意重载的代码是如何根据调用代码来推断方法名和参数的：</code>$obj-&gt;runOverloadedTest(‘in an object context’); OverloadedMethodTest::runOverloadedTest(‘in a static context’); // As of PHP 5.3.0<code>要使用这种能力，程序员需要承担较大的责任。虽然重载为编写灵活的代码提供了便利，但同时也为错误提供了土壤。所以，使用重载时应该谨慎，并且要有严格的代码测试纪律。 **变量解析和 heredoc** PHP 的优势之一在于字符串解析。PHP 对于字符串的长度没有限制，只要主机的可用内存够大就行。下面代码展示了使用 PHP 时拥有的灵活性。</code>coffee’s taste is great He drank a number of He drank some coffees He drank some coffees<code>这样的代码并不是直到 PHP V5.3.0 才有的。这里给出这段代码，只是为了提醒您字符串处理支持和一些解析规则。但是，PHP V5.3.0 增加了增强的 heredoc 语法支持。下面显示了一个简单的例子。</code>&gt;&gt;”FOOBAR” Hello World! FOOBAR; ?&gt;<code>代码产生以下令人惊叹的输出：</code>Hello World!` 那么，上面的代码有什么特别之处呢？PHP V5.3.0 中的 heredoc 支持使用双引号。其优点主要在于，双引号中的内容不会被解析，这样便有了更大的灵活性。基本上，这只是在已经强大的字符串支持的基础上增加了更多的灵活性。PHP V5.3.0 的在线参考包括更多关于这个主题和 PHP V5.3.0 其他相关主题的资料。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php5.3</tag>
        <tag>命名空间</tag>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>apache下ab网站压力测试命令参数及输出结果的中文注解</title>
    <url>/posts/68.html</url>
    <content><![CDATA[<p>以前安装好APACHE总是不知道该如何测试APACHE的性能，现在总算找到一个测试工具了。就是APACHE自带的测试工具AB(apache benchmark).在APACHE的bin目录下。 <code>格式： ./ab [options] [http://]hostname[:port]/path</code> 参数： -n requests Number of requests to perform //在测试会话中所执行的请求个数。默认时，仅执行一个请求 -c concurrency Number of multiple requests to make //一次产生的请求个数。默认是一次一个。 -t timelimit Seconds to max. wait for responses //测试所进行的最大秒数。其内部隐含值是-n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -p postfile File containing data to POST //包含了需要POST的数据的文件. -T content-type Content-type header for POSTing //POST数据所使用的Content-type头信息。 -v verbosity How much troubleshooting info to print //设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出。 -w Print out results in HTML tables //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。 -i Use HEAD instead of GET // 执行HEAD请求，而不是GET。 -x attributes String to insert as table attributes // -y attributes String to insert as tr attributes // -z attributes String to insert as td or th attributes // -C attribute Add cookie, eg. ‘Apache=1234. (repeatable) //-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复。 -H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’ Inserted after all normal header lines. (repeatable) -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. //-P proxy-auth-username:password 对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。 -X proxy:port Proxyserver and port number to use -V Print version number and exit -k Use HTTP KeepAlive feature -d Do not show percentiles served table. -S Do not show confidence estimators and warnings. -g filename Output collected data to gnuplot format file. -e filename Output CSV file with percentages served -h Display usage information (this message) //-attributes 设置 属性的字符串. 缺陷程序中有各种静态声明的固定长度的缓冲区。另外，对命令行参数、服务器的响应头和其他外部输入的解析也很简单，这可能会有不良后果。它没有完整地实现 HTTP/1.x; 仅接受某些’预想’的响应格式。 strstr(3)的频繁使用可能会带来性能问题，即, 你可能是在测试ab而不是服务器的性能。 参数很多,一般我们用 -c 和 -n 参数就可以了. 例如: <code>./ab -c 1000 -n 1000 http://127.0.0.1/index.php 这个表示同时处理1000个请求并运行1000次index.php文件. #/wp-content/local/xiaobai/apache2054/bin/ab -c 1000 -n 1000 http://127.0.0.1/index.html.zh-cn.gb2312 This is ApacheBench, Version 2.0.41-dev &lt;$Revision: 1.121.2.12 $&gt; apache-2.0 Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/ Benchmarking 127.0.0.1 (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Finished 1000 requests Server Software: Apache/2.0.54 //平台apache 版本2.0.54 Server Hostname: 127.0.0.1 //服务器主机名 Server Port: 80 //服务器端口 Document Path: /index.html.zh-cn.gb2312 //测试的页面文档 Document Length: 1018 bytes //文档大小 Concurrency Level: 1000 //并发数 Time taken for tests: 8.188731 seconds //整个测试持续的时间 Complete requests: 1000 //完成的请求数量 Failed requests: 0 //失败的请求数量 Write errors: 0 Total transferred: 1361581 bytes //整个场景中的网络传输量 HTML transferred: 1055666 bytes //整个场景中的HTML内容传输量 Requests per second: 122.12 [#/sec] (mean) //大家最关心的指标之一，相当于 LR 中的 每秒事务数 ，后面括号中的 mean 表示这是一个平均值 Time per request: 8188.731 [ms] (mean) //大家最关心的指标之二，相当于 LR 中的 平均事务响应时间 ，后面括号中的 mean 表示这是一个平均值 Time per request: 8.189 [ms] (mean, across all concurrent requests) //每个请求实际运行时间的平均值 Transfer rate: 162.30 [Kbytes/sec] received //平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题 Connection Times (ms) min mean[+/-sd] median max Connect: 4 646 1078.7 89 3291 Processing: 165 992 493.1 938 4712 Waiting: 118 934 480.6 882 4554 Total: 813 1638 1338.9 1093 7785 //网络上消耗的时间的分解，各项数据的具体算法还不是很清楚 Percentage of the requests served within a certain time (ms) 50% 1093 66% 1247 75% 1373 80% 1493 90% 4061 95% 4398 98% 5608 99% 7368 100% 7785 (longest request)</code> //整个场景中所有请求的响应情况。在场景中每个请求都有一个响应时间，其中50％的用户响应时间小于1093 毫秒，60％ 的用户响应时间小于1247 毫秒，最大的响应时间小于7785 毫秒 由于对于并发请求，cpu实际上并不是同时处理的，而是按照每个请求获得的时间片逐个轮转处理的，所以基本上第一个Time per request时间约等于第二个Time per request时间乘以并发请求数</p>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>压力测试</tag>
      </tags>
  </entry>
  <entry>
    <title>php和asp.net的md5差别</title>
    <url>/posts/67.html</url>
    <content><![CDATA[<p>asp.net的md5加密貌似是16位的 而php的md5加密是32位的 这样解决 `echo substr(md5(“admin”),8,16); // 16位MD5加密效果等同于asp.net的md5 echo “</p>
<hr>
<p>“; echo md5(“admin”); // 32位MD5加密`</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>asp.net</tag>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title>给有重复记录的表添加唯一索引</title>
    <url>/posts/76.html</url>
    <content><![CDATA[<p>不希望数据表中有重复记录的时候我们可以给表添加一个联合唯一索引 例如，user表中有user_id,user_name两个字段，如果不希望有两条一摸一样的的user_id和user_name，我们可以给user表添加两个字段的联合唯一索引： <code>alter table user add unique index(user_id,user_name);</code> 这样当向表中添加相同记录的时候，会返回1062的添加失败信息。 但是有一种情况是表中已经有n个重复的记录，这时候我们才想起来要添加唯一索引，再执行上面的操作时，数据库会告诉你已经有重复的记录了，建立索引失败，这时候，我们可以用下面的操作： <code>alter ignore table user add unique index(user_id,user_name);</code> 它会删除重复的记录（别怕，会保留一条），然后建立唯一索引，高效而且人性化。 尤其是绿色的那条sql,在建立索引的同时删除了重复数据，相当有用。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>唯一索引</tag>
      </tags>
  </entry>
  <entry>
    <title>让我做你下一行code </title>
    <url>/posts/66.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>本人唠叨</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭window.open的子窗口并且刷新父窗口</title>
    <url>/posts/65.html</url>
    <content><![CDATA[<p>在我们会在JS中用window.open来打开一个新窗口来处理一些操作，为了有更好的用户友好性，一般在关闭window.open打开的子窗口时，同时刷新父窗口来获取最新数据。代码如下： <code>function closeMeAndReloadParent(){ opener.location.reload(); window.close(); }</code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>window.open</tag>
        <tag>父窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP Token(令牌)设计</title>
    <url>/posts/77.html</url>
    <content><![CDATA[<p>设计目标: 避免重复提交数据. 检查来路,是否是外部提交 匹配要执行的动作(如果有多个逻辑在同一个页面实现,比如新增,删除,修改放到一个PHP文件里操作) 这里所说的token是在页面显示的时候,写到FORM的一个隐藏表单项(type=hidden). token不可明文,如果是明文,那就太危险了,所以要采用一定的加密方式.密文要可逆.俺算法很白痴,所以采用了网上一个现成的方法. 如何达到目的: 怎样避免重复提交? 在SESSION里要存一个数组,这个数组存放以经成功提交的token.在后台处理时,先判断这个token是否在这个数组里,如果存在,说明是重复提交. 如何检查来路? 可选项,这个token在生成的时候,加入了当前的session_id.如果别人copy你的html(token一迸copy),在提交时,理论上token里包含的session_id不等于当前session_id,就可以判断这次提交是外部提交. 如何匹配要执行的动作? 在token的时候,要把这个token的动作名称写进这个token里,这样,在处理的时候,把这个动作解出来进行比较就行了.</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中同步两个表中的某些字段</title>
    <url>/posts/64.html</url>
    <content><![CDATA[<p>MySQL中同步两个表中的某些字段 以前我们在写update的时候往往是使用 update tablename set columnname ＝ value这样的简单语法，而今天遇到一个需求，根据一张表中的数据来更新另外一张表中的某些字段值，比如有个A表和B表，A中有字段id，name，email，phone，cno，这里的cno也是唯一的，B表中有id，othercloumn，email，phone，cno，这时候想通过B中的email和phone值来更新A中的email和phone值。我们可以使用一下语句实现这个功能： 语句1 <code>update A, B set A.email= B.email where A.cno=B.cno</code> 语句2 <code>update A set A.email= (select B.email from B where A.cno=B.cno)</code></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>两个表同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript trim()函数实现</title>
    <url>/posts/63.html</url>
    <content><![CDATA[<p>在JavaScript中我们需要用到trim的地方很多，但是JavaScript又没有独立的trim函数或者方法可以使用，所以我们需要自己写个trim函数来实现我们的目的。 方案一： 以原型方式调用，即obj.trim()形式，此方式简单且使用方面广泛，定义方式如下： <code>/** * 删除左右两端的空格 */ String.prototype.trim=function() { return this.replace(/(^\s*)|(\s*$)/g, ”); } /** * 删除左边的空格 */ String.prototype.ltrim=function() { return this.replace(/(^\s*)/g,”); } /** * 删除右边的空格 */ String.prototype.rtrim=function() { return this.replace(/(\s*$)/g,”); } //使用示例如下： alert(document.getElementById(’abc’).value.trim()); alert(document.getElementById(’abc’).value.ltrim()); alert(document.getElementById(’abc’).value.rtrim());</code> 方案二： 以工具方式调用，即trim(obj)的形式，此方式可以用于特殊处理需要，定义方式如下： <code>/** * 删除左右两端的空格 */ function trim(str) { return str.replace(/(^\s*)|(\s*$)/g, ”); } /** * 删除左边的空格 */ function ltrim(str) { return str.replace(/(^\s*)/g,”); } /** * 删除右边的空格 */ function rtrim(str) { return str.replace(/(\s*$)/g,”); } //使用示例如下： alert(trim(document.getElementById(’abc’).value)); alert(ltrim(document.getElementById(’abc’).value)); alert(rtrim(document.getElementById(’abc’).value));</code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数</tag>
        <tag>javascript</tag>
        <tag>trime()</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客声称Windows 7比Linux安全</title>
    <url>/posts/62.html</url>
    <content><![CDATA[<p>Charlie Miller是黑客大赛Pwn2Own连续两年的冠军，最近他在接受访问的时候爆出，微软的Windows 7操作系统比苹果的MacOS更难攻破，当被问及Linux是否更加安全的时候，Charlie说攻击Linux操作系统实际上更加容易，之所以针对Linux的攻击较少，主要是因为其普及规模不如Windows操作系统，看样子开源软件真的并非一定安全。 Charlie还提到，Flash插件实际上是一个巨大的安全威胁，安装了Flash的浏览器都是不安全的，很容易成为黑客攻击的目标。</p>
]]></content>
      <categories>
        <category>业界新闻</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>window7</tag>
        <tag>安全</tag>
        <tag>黑客</tag>
      </tags>
  </entry>
  <entry>
    <title>人人网的系统架构</title>
    <url>/posts/59.html</url>
    <content><![CDATA[<p><strong>人人网使用的开源软件列表</strong> <strong>MySQL</strong> 关系型数据库存储系统，我们的DBA团队很强大，每人管理上百台MySQL服务器，其他就不多说了，网上资料太多了 <strong>Tokyo Cabinet</strong> 一个key-value的存储引擎，日本人开发，国内很多公司也开始使用，我们内部很多地方也用它来代替MySQL来做存储，比如我们的搜索结果页的用户资料，就是用它来做一层MySQL外的冗余存储，目的是加快搜索结果页的显示。在key-value并需要持久存储的场景下，用它比MySQL更有效，Cabinet本身只是一个存储引擎，没有网络处理能力，你可以用它作为自己的某个系统的下层存储引擎，更好的是搭配Tokyo Tyrant使用。 <strong>Tokyo Tyrant</strong> 一个支持Memcached传输协议的网络接口，由Tokyo Cabinet的作者开发，目的是为Tokyo Cabinet提供网络接入能力，即Tokyo Tyrant处理网络连接，协议解析，然后调用Tokyo Cabinet的API来完成持久化存储。 <strong>ICE</strong> 一个跨语言的网络通讯框架，框架本身提供了强大的通讯能力，管理工具，负载均衡方案，其跨语言能力也是一个很大的亮点，基于这个框架之上，我们选用合适的语言来提供合适的服务，比如我们使用C++来开发Cache服务，使用Java来开发一些逻辑服务。框架本身可以很重，也可以很轻，具体要看你怎么用：） <strong>Memcached</strong> 一个纯内存的key-value的cache系统，高效、稳定，使用广泛，如果你连它都没听说过就太out啦，memcached本身不具备分布式能力，需要依靠Client来实现分布，这里强调一点的是，你应该选择一致性Hash来做key的分布。各种语言的client都有，我们使用spymemcached作为java的Client，spymemcached是一个异步的NIO的memcached client，对网络IO的处理非常的精巧，也更加高效，同时因为提供异步操作方式，可以让你对Memcached的操作有更好的控制能力，Memcached到1.4.0版本之后，开始支持binary protocol，spymemcached对其也支持的比较好，使用binary protocol可以提高对协议的解析效率和网络IO的读写效率。 上面说到我们使用ICE自己开发了Cache服务，为什么我们还要用Memcached呢？主要在对Cache的操作粒度不一样，Memcached对Cache对象以binary byte作为一个整体来操作，需要频繁的序列化和反序列化，我们使用ICE提供的Cache服务，可以以Cache对象的一个或者多个字段来操作，比如一个用户对象，我们可以只更新它的姓名，而Memcached <strong>Nginx</strong> 高效、稳定的Web Server，我们利用其代理能力，做跨IDC的请求代理，同时也将其和我们的Resin(Java Web 容器)搭配，放在Resin的前面来解决Resin的对网络连接处理能力弱的问题，在一些小地方也用它来做7层的负载均衡 <strong>Resin</strong> 一个Java Web Server，比Tomcat更高效，是我们主要的Java Web容器 <strong>Squid</strong> 代理服务器，我们用他来做图片文件的反向代理缓存 <strong>LVS</strong> 能提供4层的负载均衡，高效、高可用，高并发。我们用他替代了很多硬件的负载均衡设备 <strong>Struts</strong> Java web框架，不过这个已经是历史了，我们开发了一套自己的Web框架替代了它，未来我们也会把我们的内部的这套Web框架开源出来 <strong>Lucence</strong> 基于Java的搜索引擎框架，用它我们构建了一个搜索集群来提供搜人的服务 <strong>Netty</strong> 一个Java的网络框架，和apache的mina类似，但比mina更高效，我们用来做一些小的服务 <strong>Ganglia</strong> 一个监控系统，帮组我们了解我们每台Server的资源利用情况</p>
]]></content>
      <categories>
        <category>WEB相关</category>
      </categories>
      <tags>
        <tag>人人网</tag>
        <tag>系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title>如何计算域名过期时间？(转)</title>
    <url>/posts/58.html</url>
    <content><![CDATA[<p>首先我们先来了解一下域名的各种状态及域名注册与删除周期。 <strong>国际域名注册与删除周期</strong> <a href="http://www.phpkoo.com/attachment/56/" target="_blank" rel="noopener" title="international_domain.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/2573596715.jpg" alt="international_domain.jpg"></a> 通常情况下，英文国际域名分为四种状态：活动期、注册商保留期、赎回期以及删除期。 1. Active：国际域名在活动状态，最少注册时长不少于1年，最多注册时长不超过10年。 2. On Hold：注册商保留期，一般为30天（Oray所注册顶级域名的保留期大约为30天），此期间虽然域名过期了，但用户仍然可以通过Oray对域名进行续费。 3. RGP：赎回期，为40天，此期间用户必须付出高昂的费用才能重新获得该域名的拥有权。 4. Soon To Expire：删除期，为5天，此期间域名无法注册和赎回。 5. 四种状态过后，域名管理机构释放域名给公众注册。  <strong>国内域名注册与删除周期</strong> <a href="http://www.phpkoo.com/attachment/57/" target="_blank" rel="noopener" title="internal_domain.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/2001886895.jpg" alt="internal_domain.jpg"></a> 通常情况下，国内域名分为三种状态 1. Active：国内域名在活动状态，最少注册时长不少于1年，最多注册时长不超过10年。 2. On Hold：注册商保留期，一般为1-45天（Oray所注册顶级域名的保留期大约为30天），此期间虽然域名过期了，但用户仍然可以通过Oray对域名进行续费。 3. RGP：赎回期，为15天，此期间用户必须付出高昂的费用才能重新获得该域名的拥有权。 4. 三种状态过后，域名管理机构释放域名给公众注册。 可以看到，相比之下，国内域名过期后，释放出来给公众注册的时间比国际域名快，因此要更加注意对域名进行及时的续费。</p>
]]></content>
      <categories>
        <category>WEB相关</category>
      </categories>
      <tags>
        <tag>国内域名</tag>
        <tag>国际域名</tag>
        <tag>域名续费</tag>
      </tags>
  </entry>
  <entry>
    <title>在线Loading图标制作</title>
    <url>/posts/55.html</url>
    <content><![CDATA[<p>Load Info在线制作Loading图标的免费网站，目前网站提供了90多种（总有一种适合你）动态图标。 点击图片,可以自定义背景色和前景色，更有三种不同的尺寸可以选择，包括 16×16, 24×24, 48×46，很是方便实用。 <a href="http://www.phpkoo.com/attachment/53/" target="_blank" rel="noopener" title="Load Info.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/2217506759.jpg" alt="Load Info.jpg"></a>  Ajax Load同样可以在线制作Loading图标, Ajax Load所提供的种类没有Load Info丰富，不是先看到Loading的样式,下拉菜单选择样式,点击生成才能看到具体的样式 <a href="http://www.phpkoo.com/attachment/54/" target="_blank" rel="noopener" title="Ajax Load.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/4255942358.jpg" alt="Ajax Load.jpg"></a> 点击进入 <a href="http://loadinfo.net/" target="_blank" rel="noopener" title="loadinfo">loadinfo</a> 点击进入 <a href="http://ajaxload.info/" target="_blank" rel="noopener" title="ajaxload">ajaxload</a></p>
]]></content>
      <categories>
        <category>WEB相关</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>在线loading图标制作</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql 查询Case使用</title>
    <url>/posts/52.html</url>
    <content><![CDATA[<p>sql代码 <code>SELECT id,title,CASE WHEN status=&#39;1&#39; THEN &#39;已审核&#39; ELSE &#39;未审核&#39; END AS status FROM table</code> 原表 id title status 1 我 1 2 我的 0 最后显示 显示 id title status 1 我 已审核 2 我的 未审核</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>case</tag>
        <tag>sql</tag>
        <tag>查询</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql对自动编号字段(auto_increment)进行排序</title>
    <url>/posts/51.html</url>
    <content><![CDATA[<p>在一个数据表里面的id使用是用auto_increment，如果删除了中间某条信息会使用其id断序，从而使用以下语句可以对其重新排序。 SQL代码 <code>SET @newid=0; update table_name set id = (SELECT @newid:=@newid+ 1);</code></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>排序</tag>
        <tag>自动编号</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql自定义变量</title>
    <url>/posts/50.html</url>
    <content><![CDATA[<p>SQL代码 <code>SET @name=&quot;abc&quot;; /* 赋值 */ SET @name:=&quot;abc&quot;; /* 赋值 */ /* 以上两句结果相同 */ SELECT @name=&quot;abc&quot;; /* 比较操作符 */ SELECT @name:=&quot;abc&quot;; /* 赋值 */ /* 以上两句结果不同 */</code> 这里定义了两个变量，@name和@id，后面进行相应的替换就可以了。以后，直接修改变量的值即可。其中，用“=”等号或者用“:=”冒号加等号，在SET命令里面都是一样的。 但不同的是，要在非SET命令中定义变量时，必须使用“:=”，因为“=”会被认为是比较操作符（这个是比较高级的内容了，暂时不深究）。 自定义变量可以用数字，字母，“.”点符号，“_”下划线，“$”美元符号。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>自定义变量</tag>
      </tags>
  </entry>
  <entry>
    <title>12580内部邮件宣布李一男出任CEO兼总裁</title>
    <url>/posts/49.html</url>
    <content><![CDATA[<p>无限讯奇公司(中国移动12580独家合作伙伴)近日的一封内部邮件宣布，百度原首席技术官李一男加盟出任董事、CEO兼总裁，原CEO、创始人张志浩出 任联席董事长。 在百度1月18日宣布李一男离开的当天，业内既有消息称李一男将出任12580公司CEO。有媒体当时报道称，12580将于20日宣布李一男的加盟，但 最终这一天并未宣布。网易科技获悉，李一男是在次日(21日)到无线讯奇上班的，该公司的内部邮件近日宣布了李一男的加盟。 内部邮件显示，现任首席执行官张志浩将出任公司联席董事长。张志浩是12580的创始人之一。李一男被聘为无限讯奇公司董事、CEO 兼总裁。邮件称，李一男将从3月1日起正式上班，从1月20日起至2月底，张志浩继续代行CEO职权。 李一男在加盟百度出任首席技术官16个月后离职，这在一周前引发了业界的轩然大波。李一男是少年天才，曾担任华为副总裁，以卓越的技术闻名于业内；李一男也是继COO叶朋之后，百度10天之内离职的第二位核心高管，外界也由此开始担忧百度的未来。 以下为内部邮件全文： 自2010 年1 月20 日起，张志浩先生不再担任公司首席执行官（CEO）职务，出任公司联席董事长。李一男先生被聘任为公司董事、CEO 兼总裁。 在加入无限讯奇之前，李一男先生曾担任过华为公司副总裁，港湾网络公司总裁，百度公司首席技术官（CTO）。李先生具有卓越的技术背景、丰富的管理经验以及在业界的影响力。 让我们预祝公司在李一男先生的带领下，在未来将取得更大的成功。李一男先生将于2010年3 月1 日起正式上班。即日起至2010 年2月28 日之间，张志浩先生代行CEO 职权。 转载：phpchina</p>
]]></content>
      <categories>
        <category>业界新闻</category>
      </categories>
      <tags>
        <tag>12580</tag>
        <tag>CEO</tag>
        <tag>李一男</tag>
      </tags>
  </entry>
  <entry>
    <title>盖茨点评谷歌：谷歌退出美国 那才佩服它</title>
    <url>/posts/48.html</url>
    <content><![CDATA[<p>“你必须做出决定：如果你愿意遵守你所在国家的法律，你就可以留下做生意，不愿意遵守的话，你在那里做生意可能不会有好下场。” 　　微软公司创始人比尔·盖茨25日在谈及近期的谷歌中国事件时指出，如果跨国公司想在某一个国家做生意，就必须遵守这个国家的法律。 　　盖茨是在接受美国广播公司节目“早安美国”的采访时作此表示的。他说：“你必须做出决定：如果你愿意遵守你所在国家的法律，你就可以留下做生意，不愿意遵守的话，你在那里做生意可能不会有好下场。” 　　盖茨表示，虽然互联网上的内容受到了全世界各种标准不一的审查制度的影响，但是其在促进全世界互相开放与交流方面还是发挥了巨大的作用。 　　同时，据国外媒体报道，1月25日比尔·盖茨拜访了纽约时报。盖茨对微软和谷歌的互联网搜索工作表达了自己的看法，言辞时而敏锐严厉，时而嘲讽尖酸。 　　对于谷歌最近为抗议中国对搜索的审查制度，而威胁要放弃中国的搜索业务的事件，盖茨称自己并没什么印象，甚至有些困惑。他说：“他们什么都没做，却把功劳照单全收。” 　　他认为，一个人可能会也可能不同意中国的法律，但是几乎所有国家都有一些颇具争议性的法律或政策，包括美国。“他们想说明什么?”盖茨问道，“现在如果谷歌选择退出美国，那我才佩服它。” 　　谷歌逼盖茨表态 　　为什么奥巴马政府对谷歌支持?因为过去竞选的时候，它对奥巴马竞选的团队有过贡献，金钱的贡献。在很多状况之下，美国的民主政策基于两票，一票是选票，一票是钞票，钞票发挥功能进行各种游说，或者是有必要时获得政府支持。过去谷歌用钞票支持了奥巴马，现在奥巴马政府进行了回报。 　　十几天以来，谷歌事件在美国的媒体、美国的学术界引起不同的反应。《今日美国》最近就讲，谷歌事件是一种商业炒作，因为谷歌自己本身提不出来正确，而且可以信服的证据。 　　最近谷歌在这个事情上也打到了微软，因为微软在中国事业做得很大，它打到了微软。逼得微软的创始人比尔·盖茨表态，因为谷歌说中国政府是进行检查。比尔·盖茨说在全世界各地做生意，各国都有各种法律的限制。 　　比尔·盖茨这个言论，当然从业界的角度考虑，也是让美国的民间、美国的媒体进一步了解这个世界的真理不是只有你谷歌一个。(阮次山) 　　谷歌退出事件 　　1月13日，谷歌以遭到黑客攻击为由宣布考虑关闭中国办事处。1月21日美国国务卿希拉里在华盛顿发表关于”网络自由”的演讲，指责中国等国家的互联网管理政策，并表示要将”不受限制的互联网访问作为外交政策的首要任务”。针对各种无端指责，继中国外交部之后，中国工业和信息化部以及国务院新闻办公室日前相继作出回应，强调中国互联网发展取得了举世瞩目的成就，中国互联网的政策环境是好的，中国互联网发展和管理的方针政策符合中国国情和国际通行做法。 转载：phpchina</p>
]]></content>
      <categories>
        <category>业界新闻</category>
      </categories>
      <tags>
        <tag>盖茨</tag>
        <tag>谷歌</tag>
      </tags>
  </entry>
  <entry>
    <title>网站开发流程(图文版)</title>
    <url>/posts/38.html</url>
    <content><![CDATA[<p>网站开发流程(图文版) 开发过程中三个角色：程序员，设计师和客户 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165229862.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165229862.jpg" alt="20061129165229862"></a> 步骤1：项目讨论 在接到项目后首先需要开项目开发讨论会，讨论网站的栏目，开发方向，文字内容和图片等等。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165232536.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165232536.jpg" alt="20061129165232536"></a>  步骤2：激发灵感 考虑网站结构，认识客户中心思想要体现的内容，按客户需求展开创意的灵感。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165232228.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165232228.jpg" alt="20061129165232228"></a> 步骤3：框架导航 程序员和设计师具体讨论网站整体制作 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165232135.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165232135.jpg" alt="20061129165232135"></a> 步骤4：项目计划 项目大概工作量和所需的时间，写成项目计划书给客户看 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233424.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233424.jpg" alt="20061129165233424"></a> 步骤5：设计初稿 设计师作最基本的设计工作，主页和主要分页。设计师作最基本的设计工作，主页和主要分页。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233604.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233604.jpg" alt="20061129165233604"></a> 步骤6：客户反馈 客户对设计初稿提出建议。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233395.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233395.jpg" alt="20061129165233395"></a> 步骤7：重新设计 跟据客户对设计初稿建议和项目需求，进行修改设计或重新设计。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233743.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233743.jpg" alt="20061129165233743"></a> 步骤8：客户满意 经过：设计初稿-客户反馈-重新设计的过程，最后得到了客户的满意。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233108.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233108.jpg" alt="20061129165233108"></a> 步骤9：其它页设计 最基本的设计同意, 您就能开始制作站点每个页的布局和设计。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233206.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233206.jpg" alt="20061129165233206"></a> 步骤10：客户确认 再一次让客户反馈，得到最后确认。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233210.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233210.jpg" alt="20061129165233210"></a> 步骤11：制作HTML 程序员将设计师制作出的页面，作成HTML页。 <a href="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233592.jpg" target="_blank" rel="noopener"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/20061129165233592.jpg" alt="20061129165233592"></a> 步骤12：…和CSS 对网站完成CSS和其它工作。 <a href="http://www.phpkoo.com/attachment/43/" target="_blank" rel="noopener" title="image013.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/2573762484.jpg" alt="image013.jpg"></a> 步骤13：交给客户 程序员，设计师完成的工作，交给客户反馈，直到站点完成。 <a href="http://www.phpkoo.com/attachment/44/" target="_blank" rel="noopener" title="image014.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/4142243317.jpg" alt="image014.jpg"></a> 步骤14：测试 项目最后阶段是测试。站点需要进行跨平台测试，解决所技术问题和错误。 <a href="http://www.phpkoo.com/attachment/45/" target="_blank" rel="noopener" title="image015.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/3461040768.jpg" alt="image015.jpg"></a> 步骤15：发布 最后收款，完成项目。 <a href="http://www.phpkoo.com/attachment/46/" target="_blank" rel="noopener" title="image016.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/3825264992.jpg" alt="image016.jpg"></a></p>
]]></content>
      <categories>
        <category>本人唠叨</category>
      </categories>
      <tags>
        <tag>网站开发流程</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP简单批量生成不重复的虚拟充值卡号密码</title>
    <url>/posts/29.html</url>
    <content><![CDATA[<p>在很多时候我们需要一些虚拟充值卡或优惠卡等信息，现提供PHP下实现此功能的代码。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>生成充值卡</tag>
      </tags>
  </entry>
  <entry>
    <title>md5 结合 crypt ＝无敌密码</title>
    <url>/posts/28.html</url>
    <content><![CDATA[<p>PHP的内置函数crypt 很不错 配合MD5 更天下无敌 <code>&quot;; //不安全 echo &quot;crypt加密后&quot;.crypt($pass).&quot;  
&quot;; // 比较乱的密码 刷新后还会变 echo &quot;crypt复杂加密后&quot;.crypt($pass,substr($pass,0,2)).&quot;  
&quot;; //还是不爽 echo &quot;无敌加密后&quot;.md5(crypt($pass,substr($pass,0,2))).&quot;  
&quot;; // 现在让黑客如何破这个密码？ ?&gt;</code> 最后的密码 还是32位 初看 都以为是 MD5加密 可无论对方MD5的HASH值多么庞大 几个T的数据 都无法破解出来</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>crypt</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>一个必须得改的毛病</title>
    <url>/posts/27.html</url>
    <content><![CDATA[<p>最近在公司，做一个数据库更新的事，由于当时条件没有考虑周全，把部分VIP用户的标识给恢复了，当初购买时的会员标识，因为只有一小部分用户有此问题，所有公司没有及时发现，后来用户通知我们了，我们才发现，还是影响的数据量不大，发了大概半小时时间把它处理完，幸好有“历史数据”处理机制在，要不然完完了，，不知道数据从哪来恢复。 仔细想想自己的一些问题都出在真的太粗心了，以后真的得改掉这个毛病。记住这个教训。 ps:真的记得得改。</p>
]]></content>
      <categories>
        <category>本人唠叨</category>
      </categories>
      <tags>
        <tag>个人唠叨</tag>
      </tags>
  </entry>
  <entry>
    <title>分享招聘信息</title>
    <url>/posts/24.html</url>
    <content><![CDATA[<p>无意中，发现一网友博文中的图片，觉得挺搞，特引来分享分享，图如下：<a href="http://www.phpkoo.com/attachment/26/" target="_blank" rel="noopener" title="2510408727.jpg"><img src="http://www.phpkoo.com/wp-content/uploads/2010/01/810639164.jpg" alt="2510408727.jpg"></a></p>
]]></content>
      <categories>
        <category>本人唠叨</category>
      </categories>
      <tags>
        <tag>分享招聘信息</tag>
        <tag>招聘</tag>
      </tags>
  </entry>
  <entry>
    <title>博客再次迁移</title>
    <url>/posts/21.html</url>
    <content><![CDATA[<p>在国内架个个人博客真难，由于国内互联内“反黄”事件，全国各大机房都接连被封机房，本站之前放于广州地界的机房，也同样被封长于半个月的时间，机房也没有相应的补尝，由于主机也将至到期，心想干脆换个机房，换程序移到了杭州机房，本以为此次风波已经过去，没想到经过一周多时间，问题同上的发生，还好，最新数据本地都已存在（经上次的教训），在本地都已经备案了最新的数据和程序。CNNIC 真是太暴力了也没有点时间，直接说封就封。听说1月底还要对CN域名下手，今年刚续完费，不知道能不能撑不撑的过去。一直也想把之前一直用的SABLOG给换了，借此机会，就干脆把它也换成TYPECHO算了，个人认为TYPECHO比较适合做博客程序，较WORDPRESS相比没有其臃肿，在皮肤上跟WORDPRESS较接近，同时在插件的使用和开发都是相对比较简单，最重要的一点同时也是开源程序，而且就连数据库的注释也是非常的清楚，这点各大大博客包括WORDPRESS好像都没做到，TYPECHO还可以直接在GOOGLE的开源项目上直接获取其源码。SABLOG也是比较优秀但更新比较慢，皮肤也少,UI也做的不好。其综合比较个人还是觉得TYPECHO比较好，希望有越来越多的人会去使用它。 发布于，<a href="http://www.phpkoo.com" target="_blank" rel="noopener" title="站长实验室">站长实验室</a></p>
]]></content>
      <categories>
        <category>本人唠叨</category>
      </categories>
      <tags>
        <tag>博客迁移</tag>
        <tag>站长实验室</tag>
      </tags>
  </entry>
  <entry>
    <title>网站架构策划方案</title>
    <url>/posts/9.html</url>
    <content><![CDATA[<p>这段时间一直都在为网站架构的事情所烦恼，前端，程序，服务器三个方面应该如何协调才能达到一个较为优化的网站架构呢？根据前辈的经验，我总结了以下文档，特分享。 <strong>1. UIC需要做的</strong> 采用Css Sprite将背景图片，图标图片集成在一张图片内。 优点：减少用户代理对服务器的请求次数；加快用户载入页面时间。 Css &amp;&amp; Js 统一使用YUIcompressor进行代码压缩处理。 优点：加快服务器结束线程的时间；加快用户载入页面时间。 单个数据对象小于25K。 优点：部分用户代理（如iphone），无法载入25K以上的数据对象。 外部广告图片，宣传图片尽量防止在本站图片缓存服务器上。 优点：减少用户的DNS查询，加快页面载入速度。 色彩不超过256色的图片，不采用JPG格式存储。 优点：减少文件大小，加快页面载入速度。 使用PNG8格式的PNG图片代替Gif格式图片。 优点：具备比Gif更高的压缩比，有利于网络传塑，加快页面载入速度。 JPG图片采用interlaced模式存储。 优点：色彩复杂的图片大小更小，可让图片呈渐进状态显示，直至清晰。增强用户体验。 <strong>2. UI 需要做的</strong> 设计稿图片尽量减少一些渐变效果的使用 优点：减少JPG图片的数量，加快用户载入页面时间。 <strong>3. 开发需要做的</strong> 如果出现Ajax 方式，采用Ajax缓存 可考虑 <strong>4. SA 需要做的</strong> 负载均衡 优点：减小Web服务器压力。 Gzip压缩输出 优点：减小输出的用户数据大小，加快页面载入时间。 图片与Web服务器分离 优点：减小Web服务器压力。 增加Squid缓存 优点：避免2次刷新带来的重复请求。减少服务器压力。 架构SVN测试服务器并与公网服务器的同步 优点：避免公网页面出现错误，增强用户体验。</p>
]]></content>
      <categories>
        <category>本人唠叨</category>
      </categories>
      <tags>
        <tag>方案</tag>
        <tag>策划</tag>
        <tag>网站架构</tag>
      </tags>
  </entry>
  <entry>
    <title>二级域名的完美实现</title>
    <url>/posts/13.html</url>
    <content><![CDATA[<p>首先，你的拥有一个有泛域名解析的顶级域名，例如： domain.com 其次，在 httpd.conf 中打开 mod_rewrite 之后，在 httpd.conf 的最后，添加以下内容： <code>RewriteEngine on RewriteMap lowercase int:tolower RewriteMap vhost txt:/wp-content/local/etc/apache/vhost.map RewriteCond ${lowercase:%{SERVER_NAME}} ^(.+)$ RewriteCond ${vhost:%1} ^(/.*)$ RewriteRule ^/(.*)$ %1/$1</code> 其中的 /wp-content/local/etc/apache 是你的 apache 服务器配置文件所在路径，根据实际情况更改。 然后，在这个所在路径的目录下创建一个文件： vhost.map 内容为： <code>www.domain.com /wp-content/local/www/data-dist/domain bbs.domain.com /wp-content/local/www/data-dist/bbs anyname.domain.com /wp-content/local/www/data-dist/anyname</code> 以上部分都是：” 域名+空格+绝对路径” 的形式。 最后，在你的网站根目录 /wp-content/local/www/data-dist 下，创建对应目录： domain , bbs , anyname 等等，理论上可以无限。 这样，通过浏览器，访问 <a href="http://www.domain.com" target="_blank" rel="noopener">www.domain.com</a> 时，实际上访问的就是 /wp-content/local/www/data-dist/domain目录下的文件。同理，访问 bbs.domain.com 实际上访问的就是 /wp-content/local/www/data-dist/bbs 目录下的文件。而且，你可以 随时更改 vhost.map 来增加、删除、修改你的二级域名和所指向的实际路径，不用重启 apache。</p>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>二级域名</tag>
        <tag>泛域名</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP各加速利器</title>
    <url>/posts/7.html</url>
    <content><![CDATA[<p>在一些较大项目中如牵涉到要整合用PHP开发的OA办公等系统，可以使用以下PHP的资源，特整理以供大家学习参考 加速器/缓存 <strong>afterBurner Cache</strong> 早期的 PHP Cache 之一。缓存编译后（第一次执行以后）的PHP 代码。宣称节省40%的运行时间。但是目前开发进度比较慢,兼容PHP 4.1系列。支持操作系统：Linux。 国家:意大利 网址：<a href="http://afterburner.bware.it/" target="_blank" rel="noopener">http://afterburner.bware.it/</a> 价格：Free <strong>APC</strong> 早期的 PHP Cache 之一。曾经是communityconnect的东西，现在是 PECL 中的一部分。 国家:美国 网址：<a href="http://pecl.php.net/package/APC" target="_blank" rel="noopener">http://pecl.php.net/package/APC</a> 价格：Free <strong>PHP Accelerator</strong> Zend 引擎扩展，由ionCube 公司开发 宣称可将脚本运行速度提高5倍。目前兼容PHP 4.3 系列。Yahoo 采用它作为PHP 缓存。支持操作系统：Linux, OpenBSD, FreeBSD, BSDi。Apache 服务器。不兼容Zend Optimizer。 国家:英国 网址：<a href="http://www.php-accelerator.co.uk/" target="_blank" rel="noopener">http://www.php-accelerator.co.uk/</a> 价格：Free <strong>Zend Performance Suite</strong> 不用我多介绍了 Zend 公司出品。兼容Zend Optimizer。支持最新的PHP和Apache服务器。 服务器吞吐量提高25倍。价格昂贵。众多商业用户包括著名搜索网站alltheweb.com。支持操作系统：Linux，新近推出windows测试版本。 国家：美国 网址：<a href="http://www.zend.com/store/products/zend-performance-suite.php" target="_blank" rel="noopener">http://www.zend.com/store/products/zend-performance-suite.php</a> 价格：$1875起 编码器 <strong>SourceGuardian Pro for PHP</strong> 为PHP脚本提供基于时间, IP and 域名 限制保护，需要一个Loader才能执行。Loader可以免费下载。和Zend Optimizer， PHPAccelerator 加速器兼容。支持虚拟主机甚至PHP 安全模式，无需服务器特殊设定。 国家：美国 网址：<a href="http://sourceguardian.com/products/phppro.htm" target="_blank" rel="noopener">http://sourceguardian.com/products/phppro.htm</a> 价格：$250 <strong>Zend Encoder</strong> Zend 公司出品。将PHP 脚本预编译成中间码格式通过Zend Optimizer运行，速度快，但是价格昂贵。 国家：美国 网址：<a href="http://www.zend.com/store/products/zend-performance-suite.php" target="_blank" rel="noopener">http://www.zend.com/store/products/zend-performance-suite.php</a> 价格：$960 <strong>ionCube Standalone PHP Encoder 3.0</strong> 将PHP 脚本预编译成二进制代码， 并提供通过多种方式保护PHP程序， 通过IP加服务器名保护， 时间过期保护， 甚至MAC地址的保护。 经过编码的PHP 程序需要一个Loader才能执行。Loader可以免费下载。支持多种操作系统：Intel Linux, FreeBSD, Windows 同时还提供在线编码服务。 国家：美国 网址：<a href="http://www.ioncube.com/sa_encoder.php" target="_blank" rel="noopener">http://www.ioncube.com/sa_encoder.php</a> 价格：$199-$348 ========================================================== shukebeita的隆重推荐 <strong>MMCache</strong> 如果想同时拥有加速和编码功能而且免费？没有问题，MMCache 是你唯一的选择。它功能强大甚至击败Zend 公司的Performance suite 而且完全免费。保护php源码。 国家：德国/俄罗斯 网址：<a href="http://turck-mmcache.sourceforge.net/" target="_blank" rel="noopener">http://turck-mmcache.sourceforge.net/</a> 价格：free</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>cache</tag>
        <tag>加速</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql异常</title>
    <url>/posts/12.html</url>
    <content><![CDATA[<p>SQLWARNING是对所有以01开头的SQLSTATE代码的速记。 NOT FOUND是对所有以02开头的SQLSTATE代码的速记。 SQLEXCEPTION是对所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的速记。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-AJAX类</title>
    <url>/posts/8.html</url>
    <content><![CDATA[<p>随着WEB2.0的到来，AJAX技术成为了网站首选的靓点技术，从表单提交到“无刷新”体验，从而在给用户带来友好体验的同时又提高与数据库的快速交互。为方便“新手”更方便的让网站使用AJAX技术，本人特封装一个小型的AJAX类如下代码 <code>/* @package Ajax类 * @author 阿德 * @version 0.1 * @dependence 09.12 * @link http://www.zzlabs.com.cn * * domId = &#39;result&#39;; * url = &#39;result.php&#39;; * parameter = &#39;id=&#39;+id; * method = &#39;get&#39;; //传输方式 * asynchronism = true //是否异步 * new Ajax().ajaxRequest(domId,url,parameter,method,asynchronism,function callBack(result){$(&#39;result&#39;).innerHTML = result.responseText;}); */ if ($ == undefined){ var $ = function(id){return document.getElementById(id);} } function Ajax(){ var _domId = null; var _xmlHttp = null; var _isAsynchronism = true; var _successFunction = null; this.createXMLHttpRequest = function(){ try{ if(window.ActiveXObject){ _xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } else { if(window.XMLHttpRequest){ _xmlHttp = new XMLHttpRequest(); } else{ _xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } } } catch(e){ alert(e.name + &quot; : &quot; + e.message); } }; this.doPost = function(_url, _parameter){ try{ _xmlHttp.open(&quot;POST&quot;, _url, _isAsynchronism); _xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); _xmlHttp.send(_parameter); } catch(e){ alert(e.name + &quot; : &quot; + e.message); } }; this.doGet = function(_url, _parameter){ try{ var _random = Math.round(Math.random() * 10000); var _getParameter = (_url + &quot;?random=&quot; + _random + &quot;&amp;&quot; + _parameter); if(_getParameter.length &gt; 255) { this.doPost(_url, _parameter); } else{ _xmlHttp.open(&quot;GET&quot;, _getParameter,_isAsynchronism); _xmlHttp.send(null); } } catch(e){ alert(e.name + &quot; : &quot; + e.message); } }; this.backFunction = function(){ if(_successFunction == null){ return; } if(_isAsynchronism){ if(_domId){ switch(_xmlHttp.readyState){ case 1: $(_domId).innerHTML = &#39;请稍候，正在建立连接...&#39;; break; case 2: $(_domId).innerHTML = &#39;请稍候，正在发送数据...&#39;; break; case 3: $(_domId).innerHTML = &#39;请稍候，正在接收数据...&#39;; break; } } if((_xmlHttp.readyState == 4) &amp;&amp; (_xmlHttp.status == 200)){ _successFunction(_xmlHttp); return; } } }; this.ajaxRequest = function(_id, _url, _parameter, _method, _asynchronism, _backFunction){ this.createXMLHttpRequest(); _domId = _id; _isAsynchronism = _asynchronism; _successFunction = _backFunction; _xmlHttp.onreadystatechange = this.backFunction; if(_method.toLowerCase() == &quot;post&quot;){ this.doPost(_url, _parameter); } else if(_method.toLowerCase() == &quot;get&quot;){ this.doGet(_url, _parameter); } }; }</code> 调用说明： 1、加载JS文件（在网站的任何位置加入） 2、实例化JS类 new Ajax().ajaxRequest(domId,url,parameter,method,asynchronism,function callBack(result){$(‘result’).innerHTML = result.responseText;}); 3、参数说明 (1)domId：表示需要显示结果的容器ID号，如domId = ‘logining’，如果没有指定可以为domId=’’或domId=null (2)url：表示服务端接收的页面地址，如url = ‘send.ph’ (3)parameter：表示服务羰接收页面的参数，如parameter = ‘type=’+type，如果该页面无需参数可以为parameter = null (4)method：表示AJAX的请求方法为method = ‘get’或method=’post’ (5)asnchronism：表示是否同步，如asnchronism = true为同步,asnchronism=false为不同步，默认为同步即可 (6)function callBack()：表示是回调函数把从服务端返回的结果返回，只要在该函数中处理即可。 注：该函数只是简单的实现AJAX的基本功能，主要特点是小巧，同时可自由扩展，如果网站只需要调用AJAX功能而不需要其它复杂的功能时可以考虑使用本AJAX类。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ajax</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>禁止Apache列出目录内容</title>
    <url>/posts/14.html</url>
    <content><![CDATA[<p>默认情况下，如果你的网站下有一个a的文件夹，如果些文件夹下没有默认页面，当用户http://你的网址/a/ 即apache会把此文件夹角的内容全列出来。如果想禁止此功能，修改httpd.conf 找到下面这一句把它注释掉即可<code>Options Indexes FollowSymLinks</code>建议默认情况下，设置APACHE禁止用户浏览目录内容。</p>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>禁止目录</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP生成静态页类</title>
    <url>/posts/5.html</url>
    <content><![CDATA[<p>对 HTML 页面地抓取和收录都比动态页面更及时更全面，世界各大搜索引擎例如百度、 Googl 等。使用静态化 HTML 页面极大地增加网站被搜索到几率。让您有更多地机会展现自己。 以下提供使用PHP来静态化的类： <code>Url = $Url; $this-&gt;FileBag = $FileBag; $this-&gt;FileRoot = $FolderRoot; $this-&gt;FileName = $FolderName; $this-&gt;fileid = $fileid; Shtml::useFolder (); } /*************获取数据*******************/ public function loadcontent ($Folder) { ob_start(); require_once $this-&gt;Url; Shtml::writehtml ($Folder,ob_get_contents()); ob_clean(); } /********** 指定文件夹*****************/ public function useFolder () { if($this-&gt;FileBag==1) { $Folder=$this-&gt;FileName; } else if($this-&gt;FileBag==2) { $Folder=date(’Ymd’,time()); } else { exit($this-&gt;message1); } if(!is_dir($this-&gt;FileRoot.$Folder)){ mkdir($this-&gt;FileRoot.$Folder,0700);} Shtml::loadcontent ($Folder); } /********** 生成静态页面*****************/ public function writehtml ($Folder,$cache_value) { $file = fopen($this-&gt;FileRoot.$Folder.’/’.$this-&gt;fileid.’.html’,&#39;w+’); fwrite($file,$cache_value); fclose($file); } } $fileid=2; $shtml = new Shtml(”http://www.zzlabs.com.cn”,1,”&quot;,”cc”,$fileid); ?&gt;</code></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>类</tag>
        <tag>生成静态</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-获取浏览器窗口的大小</title>
    <url>/posts/2.html</url>
    <content><![CDATA[<p>本人将常用的JavaScript获取在不同浏览中各种窗口大小的语句整理如下，如常用的浏览器IE、FireFox、Opera等。 <code>function getInfo() { var s = “”; s += ” 网页可见区域宽：”+ document.body.clientWidth; s += ” 网页可见区域高：”+ document.body.clientHeight; s += ” 网页可见区域宽：”+ document.body.offsetWidth + ” (包括边线和滚动条的宽)”; s += ” 网页可见区域高：”+ document.body.offsetHeight + ” (包括边线的宽)”; s += ” 网页正文全文宽：”+ document.body.scrollWidth; s += ” 网页正文全文高：”+ document.body.scrollHeight; s += ” 网页被卷去的高(ff)：”+ document.body.scrollTop; s += ” 网页被卷去的高(ie)：”+ document.documentElement.scrollTop; s += ” 网页被卷去的左：”+ document.body.scrollLeft; s += ” 网页正文部分上：”+ window.screenTop; s += ” 网页正文部分左：”+ window.screenLeft; s += ” 屏幕分辨率的高：”+ window.screen.height; s += ” 屏幕分辨率的宽：”+ window.screen.width; s += ” 屏幕可用工作区高度：”+ window.screen.availHeight; s += ” 屏幕可用工作区宽度：”+ window.screen.availWidth; s += ” 你的屏幕设置是 “+ window.screen.colorDepth +” 位彩色”; s += ” 你的屏幕设置 “+ window.screen.deviceXDPI +” 像素/英寸”; //alert (s); } getInfo();</code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP会话(Session)使用入门</title>
    <url>/posts/1.html</url>
    <content><![CDATA[<p>对比起 Cookie，Session 是存储在服务器端的会话，相对安全，并且不像 Cookie 那样有存储长度限制，本文简单介绍 Session 的使用。 　　由于 Session 是以文本文件形式存储在服务器端的，所以不怕客户端修改 Session 内容。实际上在服务器端的 Session 文件，PHP 自动修改 Session 文件的权限，只保留了系统读和写权限，而且不能通过 ftp 修改，所以安全得多。 对于 Cookie 来说，假设我们要验证用户是否登陆，就必须在 Cookie 中保存用户名和密码（可能是 md5 加密后字符串），并在每次请求页面的时候进行验证。如果用户名和密码存储在数据库，每次都要执行一次数据库查询，给数据库造成多余的负担。因为我们并不能只做一次验证。为什么呢？因为客户端 Cookie 中的信息是有可能被修改的。假如你存储 $admin 变量来表示用户是否登陆，$admin 为 true 的时候表示登陆，为 false 的时候表示未登录，在第一次通过验证后将 $admin 等于 true 存储在 Cookie，下次就不用验证了，这样对么？错了，假如有人伪造一个值为 true 的 $admin 变量那不是就立即取的了管理权限么？非常的不安全。 　　而 Session 就不同了，Session 是存储在服务器端的，远程用户没办法修改 Session 文件的内容，因此我们可以单纯存储一个 $admin 变量来判断是否登陆，首次验证通过后设置 $admin 值为 true，以后判断该值是否为 true，假如不是，转入登陆界面，这样就可以减少很多数据库操作了。而且可以减少每次为了验证 Cookie 而传递密码的不安全性了（Session 验证只需要传递一次，假如你没有使用 SSL 安全协议的话）。即使密码进行了 md5 加密，也是很容易被截获的。 　　当然使用 Session 还有很多优点，比如控制容易，可以按照用户自定义存储等（存储于数据库）。我这里就不多说了。 　　Session 在 php.ini 是否需要设置呢？一般不需要的，因为并不是每个人都有修改 php.ini 的权限，默认 Session 的存放路径是服务器的系统临时文件夹，我们可以自定义存放在自己的文件夹里，这个稍后我会介绍。 　　开始介绍如何创建 Session。非常简单，真的。 　　启动 Session 会话，并创建一个 $admin 变量： 如果你使用了 Seesion，或者该 PHP 文件要调用 Session 变量，那么就必须在调用 Session 之前启动它，使用 session_start() 函数。其它都不需要你设置了，PHP 自动完成 Session 文件的创建。 　　执行完这个程序后，我们可以到系统临时文件夹找到这个 Session 文件，一般文件名形如：sess_4c83638b3b0dbf65583181c2f89168ec，后面是 32 位编码后的随机字符串。用编辑器打开它，看一下它的内容： <code>admin|N;</code> 一般该内容是这样的结构： <code>变量名|类型:长度:值;</code> 　　并用分号隔开每个变量。有些是可以省略的，比如长度和类型。 　　我们来看一下验证程序，假设数据库存储的是用户名和 md5 加密后的密码： <strong>login.php</strong> <code>$value) { $posts[$key] = trim($value); } $password = md5($posts[&quot;password&quot;]); $username = $posts[&quot;username&quot;]; $query = &quot;SELECT `username` FROM `user` WHERE `password` = &#39;$password&#39; AND `username` = &#39;$username&#39;&quot;; // 取得查询结果 $userInfo = $DB-&gt;getRow($query); if (!emptyempty($userInfo)) { // 当验证通过后，启动 Session session_start(); // 注册登陆成功的 admin 变量，并赋值 true $_SESSION[&quot;admin&quot;] = true; } else { die(&quot;用户名密码错误&quot;); } ?&gt;</code> 　　我们在需要用户验证的页面启动 Session，判断是否登陆： 是不是很简单呢？将 $_SESSION 看成是存储在服务器端的数组即可，我们注册的每一个变量都是数组的键，跟使用数组没有什么分别。 　　如果要登出系统怎么办？销毁 Session 即可。 Session 能否像 Cookie 那样设置生存周期呢？有了 Session 是否就完全抛弃 Cookie 呢？我想说，结合 Cookie 来使用 Session 才是最方便的。 　　Session 是如何来判断客户端用户的呢？它是通过 Session ID 来判断的，什么是 Session ID，就是那个 Session 文件的文件名，Session ID 是随机生成的，因此能保证唯一性和随机性，确保 Session 的安全。一般如果没有设置 Session 的生存周期，则 Session ID 存储在内存中，关闭浏览器后该 ID 自动注销，重新请求该页面后，重新注册一个 Session ID。 　　如果客户端没有禁用 Cookie，则 Cookie 在启动 Session 会话的时候扮演的是存储 Session ID 和 Session 生存期的角色。 　　我们来手动设置 Session 的生存期： 其实 Session 还提供了一个函数 session_set_cookie_params(); 来设置 Session 的生存期的，该函数必须在 session_start() 函数调用之前调用： 如果客户端使用 IE 6.0 ， session_set_cookie_params(); 函数设置 Cookie 会有些问题，所以我们还是手动调用 setcookie 函数来创建 cookie。 　　假设客户端禁用 Cookie 怎么办？没办法，所有生存周期都是浏览器进程了，只要关闭浏览器，再次请求页面又得重新注册 Session。那么怎么传递 Session ID 呢？通过 URL 或者通过隐藏表单来传递，PHP 会自动将 Session ID 发送到 URL 上，URL 形如：<a href="http://www.openphp.cn/index.php?PHPSESSID=bba5b2a240a77e5b44cfa01d49cf9669，其中" target="_blank" rel="noopener">http://www.openphp.cn/index.php?PHPSESSID=bba5b2a240a77e5b44cfa01d49cf9669，其中</a> URL 中的参数 PHPSESSID 就是 Session ID了，我们可以使用 $_GET 来获取该值，从而实现 Session ID 页面间传递。 　　对于虚拟主机来说，如果所有用户的 Session 都保存在系统临时文件夹里，将给维护造成困难，而且降低了安全性，我们可以手动设置 Session 文件的保存路径，session_save_path() 就提供了这样一个功能。我们可以将 Session 存放目录指向一个不能通过 Web 方式访问的文件夹，当然，该文件夹必须具备可读写属性。 同 session_set_cookie_params(); 函数一样，session_save_path() 函数也必须在 session_start() 函数调用之前调用。 　　我们还可以将数组，对象存储在 Session 中。操作数组和操作一般变量没有什么区别，而保存对象的话，PHP 会自动对对象进行序列化（也叫串行化），然后保存于 Session 中。下面例子说明了这一点： <strong>person.php</strong> <code>age; } function setAge($age) { $this-&gt;age = $age; } } ?&gt;</code> <strong>setage.php</strong> <code>setAge(21); $_SESSION[&#39;person&#39;] = $person; echo &#39;[check here to output age](output.php)&#39;; ?&gt;</code> <strong>output.php</strong> <code>output(); ?&gt;</code> 当我们执行 setage.php 文件的时候，调用了 setage() 方法，设置了年龄为 21，并将该状态序列化后保存在 Session 中（PHP 将自动完成这一转换），当转到 output.php 后，要输出这个值，就必须反序列化刚才保存的对象，又因为在解序列化的时候需要实例化一个未定义类，所以我们定义了以后回调函数，自动包含 person.php 这个类文件，因此对象被重构，并取得当前 age 的值为 21，然后调用 output() 方法输出该值。 　　另外，我们还可以使用 session_set_save_handler 函数来自定义 Session 的调用方式。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php会话</tag>
        <tag>session</tag>
        <tag>使用入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-confirm函数</title>
    <url>/posts/3.html</url>
    <content><![CDATA[<p>我们在对数据库进行比较高危的动作时(如：删除等)，通常系统会做出一些比较友好的提示。以下使用常规的JavaScript进行提示。 //方法1： <code>function yesno() { //方法1： confirm(”是否将此留言信息删除?”) } function yesno() { //方法2： if(confirm(”是否将此留言信息删除?”)){ return true; }else return false; }</code> <code>[删除留言](”del.asp”)</code> //方法2： 实际上，用下面的方法更简单。 <code>[删除留言](”del.asp”)</code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数</tag>
        <tag>javascript</tag>
        <tag>confirm</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 QQWry.Dat 实现 IP 地址高效检索（PHP）</title>
    <url>/posts/10.html</url>
    <content><![CDATA[<p>根据 LumaQQ 开发者文档中的纯真 IP 数据库格式详解，我编写了一个 PHP 的查询 IP 所在地区信息的类。在编写过程中发现纯真 IP 数据库格式详解中关于记录区的描述不是很全面，不过出入也不是很大，所以我没必要再写一份纯真 IP 数据库的格式说明了，大家感兴趣的话，读一读下面的代码应该就能看出来了。代码中加了很详细的注释，应该很容易读懂的。 在创建这个类的一个实例后，实例中就保存了打开的文件指针和一些查询需要的信息，每次查询时不需要重新打开文件，直到页面执行结束后，打开的文件才会自动关闭。这样。在一个页面内进行多次查询时，效率是很高的。并且此类不仅可以直接查询 IP，还可以自动将域名解析为 IP 进行查询。 下面是程序代码： iplocation.inc.php <code>fp, 4)); return $result[&#39;long&#39;]; } /** * 返回读取的3个字节的长整型数 * * @access private * @return int */ function getlong3() { //将读取的little-endian编码的3个字节转化为长整型数 $result = unpack(&#39;Vlong&#39;, fread($this-&gt;fp, 3).chr(0)); return $result[&#39;long&#39;]; } /** * 返回压缩后可进行比较的IP地址 * * @access private * @param string $ip * @return string */ function packip($ip) { // 将IP地址转化为长整型数，如果在PHP5中，IP地址错误，则返回False， // 这时intval将Flase转化为整数-1，之后压缩成big-endian编码的字符串 return pack(&#39;N&#39;, intval(ip2long($ip))); } /** * 返回读取的字符串 * * @access private * @param string $data * @return string */ function getstring($data = &quot;&quot;) { $char = fread($this-&gt;fp, 1); while (ord($char) &gt; 0) { // 字符串按照C格式保存，以\0结束 $data .= $char; // 将读取的字符连接到给定字符串之后 $char = fread($this-&gt;fp, 1); } return $data; } /** * 返回地区信息 * * @access private * @return string */ function getarea() { $byte = fread($this-&gt;fp, 1); // 标志字节 switch (ord($byte)) { case 0: // 没有区域信息 $area = &quot;&quot;; break; case 1: case 2: // 标志字节为1或2，表示区域信息被重定向 fseek($this-&gt;fp, $this-&gt;getlong3()); $area = $this-&gt;getstring(); break; default: // 否则，表示区域信息没有被重定向 $area = $this-&gt;getstring($byte); break; } return $area; } /** * 根据所给 IP 地址或域名返回所在地区信息 * * @access public * @param string $ip * @return array */ function getlocation($ip) { if (!$this-&gt;fp) return null; // 如果数据文件没有被正确打开，则直接返回空 $location[&#39;ip&#39;] = gethostbyname($ip); // 将输入的域名转化为IP地址 $ip = $this-&gt;packip($location[&#39;ip&#39;]); // 将输入的IP地址转化为可比较的IP地址 // 不合法的IP地址会被转化为255.255.255.255 // 对分搜索 $l = 0; // 搜索的下边界 $u = $this-&gt;totalip; // 搜索的上边界 $findip = $this-&gt;lastip; // 如果没有找到就返回最后一条IP记录（QQWry.Dat的版本信息） while ($l &lt;= $u) { // 当上边界小于下边界时，查找失败 $i = floor(($l + $u) / 2); // 计算近似中间记录 fseek($this-&gt;fp, $this-&gt;firstip + $i * 7); $beginip = strrev(fread($this-&gt;fp, 4)); // 获取中间记录的开始IP地址 // strrev函数在这里的作用是将little-endian的压缩IP地址转化为big-endian的格式 // 以便用于比较，后面相同。 if ($ip &lt; $beginip) { // 用户的IP小于中间记录的开始IP地址时 $u = $i - 1; // 将搜索的上边界修改为中间记录减一 } else { fseek($this-&gt;fp, $this-&gt;getlong3()); $endip = strrev(fread($this-&gt;fp, 4)); // 获取中间记录的结束IP地址 if ($ip &gt; $endip) { // 用户的IP大于中间记录的结束IP地址时 $l = $i + 1; // 将搜索的下边界修改为中间记录加一 } else { // 用户的IP在中间记录的IP范围内时 $findip = $this-&gt;firstip + $i * 7; break; // 则表示找到结果，退出循环 } } } //获取查找到的IP地理位置信息 fseek($this-&gt;fp, $findip); $location[&#39;beginip&#39;] = long2ip($this-&gt;getlong()); // 用户IP所在范围的开始地址 $offset = $this-&gt;getlong3(); fseek($this-&gt;fp, $offset); $location[&#39;endip&#39;] = long2ip($this-&gt;getlong()); // 用户IP所在范围的结束地址 $byte = fread($this-&gt;fp, 1); // 标志字节 switch (ord($byte)) { case 1: // 标志字节为1，表示国家和区域信息都被同时重定向 $countryOffset = $this-&gt;getlong3(); // 重定向地址 fseek($this-&gt;fp, $countryOffset); $byte = fread($this-&gt;fp, 1); // 标志字节 switch (ord($byte)) { case 2: // 标志字节为2，表示国家信息又被重定向 fseek($this-&gt;fp, $this-&gt;getlong3()); $location[&#39;country&#39;] = $this-&gt;getstring(); fseek($this-&gt;fp, $countryOffset + 4); $location[&#39;area&#39;] = $this-&gt;getarea(); break; default: // 否则，表示国家信息没有被重定向 $location[&#39;country&#39;] = $this-&gt;getstring($byte); $location[&#39;area&#39;] = $this-&gt;getarea(); break; } break; case 2: // 标志字节为2，表示国家信息被重定向 fseek($this-&gt;fp, $this-&gt;getlong3()); $location[&#39;country&#39;] = $this-&gt;getstring(); fseek($this-&gt;fp, $offset + 8); $location[&#39;area&#39;] = $this-&gt;getarea(); break; default: // 否则，表示国家信息没有被重定向 $location[&#39;country&#39;] = $this-&gt;getstring($byte); $location[&#39;area&#39;] = $this-&gt;getarea(); break; } if ($location[&#39;country&#39;] == &quot; CZ88.NET&quot;) { // CZ88.NET表示没有有效信息 $location[&#39;country&#39;] = &quot;未知&quot;; } if ($location[&#39;area&#39;] == &quot; CZ88.NET&quot;) { $location[&#39;area&#39;] = &quot;&quot;; } return $location; } /** * 构造函数，打开 QQWry.Dat 文件并初始化类中的信息 * * @param string $filename * @return IpLocation */ function __construct($filename = &quot;QQWry.Dat&quot;) { $this-&gt;fp = 0; if (($this-&gt;fp = @fopen($filename, &#39;rb&#39;)) !== false) { $this-&gt;firstip = $this-&gt;getlong(); $this-&gt;lastip = $this-&gt;getlong(); $this-&gt;totalip = ($this-&gt;lastip - $this-&gt;firstip) / 7; } } /** * 析构函数，用于在页面执行结束后自动关闭打开的文件。 * */ function __destruct() { if ($this-&gt;fp) { fclose($this-&gt;fp); } $this-&gt;fp = 0; } } ?&gt;</code></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>类</tag>
        <tag>class</tag>
        <tag>ip查询</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/posts/4.html</url>
    <content><![CDATA[<p>Linux 系统常用命令格式： <code>command [option] [argument1] [argument2] …</code> 其中option以“-”开始，多个option可用一个“-”连起来，如“ls -l -a” 与“ls -la”的效果是一样的。根据命令的不同，参数分为可选 的或必须的；所有的命令从标准输入接受输入，输出结果显示在标准输出，而错误信息则显示在标准错误输出设备。可使用重定向功能对这些 设备进行重定向。 命令在正常执行结果后返回一个0值，如果命令出错可未完全完成，则返回一个非零值(在shell中可用变量$?查看)。 在shell script中可用此 返回值作为控制逻辑的一部分。 <code>帮助命令: man 获取相关命令的帮助信息 例如：man dir 可以获取关于dir的使用信息。 info 获取相关命令的详细使用方法 例如：info info 可以获取如何使用info的详细信息。 文件操作： cat 显示文件内容和合并多个文件 clear 清屏 chattr 改变文件属性 chgrp 改变文件组权 chmod 改变文件或目录的权限 chown 改变文件的属权 comm 比较两个已排过序的文件 cp 将文件拷贝至另一文件 dd 从指定文件读取数据写到指定文件 df 报告磁盘空间使用情况 diff 比较两个文本文件，列出行不同之处 du 统计目录／文件所占磁盘空间的大小 file 辨识文件类型 emacs 功能强大的编辑环境 find 搜索文件并执行指定操作(find2) grep 按给定模式搜索文件内容 head 显示指定文件的前若干行 less 按页显示文件 ln 创建文件链接 locate 查找符合条件的文件 more 在终端屏幕按帧显示文本文件 mv 文件或目录的移动或更名 rm/rmdir 删除文件／目录 sed 利用script来处理文本文件 sort 对指定文件按行进行排序 tail 显示指定文件的最后部分 touch 创建文件 tr 转换字符 vi 全屏编辑器 wc 显示指定文件中的行数，词数或字符数 which 在环境变量 $PATH 设置的目录里查找符合条件的文件 压缩与备份: bzip2/bunzip2 .bz2文件的压缩/解压缩程序 cpio 备份文件 dump 备份文件系统 gzip/gunzip .gz文件的压缩/解压缩程序 gzexe 压缩可执行文件 restore 还原由倾倒(Dump)操作所备份下来的文件或整个文件系统(一个分区) tar 将若干文件存档或读取存档文件 unarj 解压缩.arj文件 zip/unzip 压缩/解压缩 zip文件 zipinfo 列出zip压缩文件的详细信息 磁盘操作: cd/pwd 切换目录/显示当前工作目录 df 显示磁盘的相关信息 du 显示目录或文件的大小 e2fsck 检查ext2/ext3文件系统的正确性 fdisk 对硬盘进行分区 fsck 检查文件系统并尝试修复错误 losetup 设置循环设备 ls 列出目录内容 mkdir 创建目录 mformat 对MS-DOS文件系统的磁盘进行格式化 mkbootdisk 建立目前系统的启动盘 mke2fs 建立ext2文件系统 mkisofs 制作iso光盘映像文件 mount/umount 加载文件系统/卸载文件系统 quota 显示磁盘已使用的空间与限制 sync 将内存缓冲区内的数据写入磁盘 tree 以树状图列出目录的内容 系统操作: alias 设置指令的别名 chkconfig 检查，设置系统的各种服务 clock 调整 RTC 时间 date 显示或设置系统时间与日期 dmesg 显示开机信息 eval 重新运算求出参数的内容 exit 退出目前的shell export 设置或显示环境变量 finger 查找并显示用户信息 free 显示内存状态 hostid 显示主机标识 hostname 显示主机名 id 显示用户标识 kill 删除执行中的程序或工作 last 列出目前与过去登入系统的用户相关信息 logout 退出系统 lsmod 显示已载入系统的模块 modprobe 自动处理可载入模块 passwd 设置用户密码 ps process status 报告程序状况 reboot 重启计算机 rhwo 查看系统用户 rlogin 远程登入 rpm 管理Linux各项套件的程序 shutdown 关机 su switch user 变更用户身份 top 显示，管理执行中的程序 uname 显示系统信息 useradd/userdel 添加用户 / 删除用户 userinfo 图形界面的修改工具 usermod 修改用户属性，包括用户的shell类型，用户组等，甚至还能改登录名 w 显示目前注册的用户及用户正运行的命令 whereis 确定一个命令的二进制执行码，源码及帮助所在的位置 who 列出正在使用系统的用户 whois 查找并显示用户信息 网络通信: arp 网地址的显示及控制 ftp 文件传输 lftp 文件传输 mail 发送／接收电子邮件 mesg 允许或拒绝其他用户向自己所用的终端发送信息 mutt E-mail管理程序 ncftp 文件传输 netstat 显示网络连接、路由表和网络接口信息 pine 收发电子邮件，浏览新闻组 ping 向网络上的主机发送 icmp echo request 包 ssh 安全模式下的远程登录 telnet 远程登录 talk 与另一用户对话 traceroute 显示到达某一主机所经由的路径及所使用的时间 wget 从网络上自动下载文件 write 向其他用户的终</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>常用命令</tag>
        <tag>管理员命令</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP中判断空变量empty(),is_null(),isset()的区别</title>
    <url>/posts/16.html</url>
    <content><![CDATA[<p><a href="http://www.php.net" target="_blank" rel="noopener" title="php">PHP</a> 中判断变量类型及是否为空主要涉及到的函数有gettype(),isEmpty(),isset(),is_null(),下表详细说<img src="http://www.phpkoo.com/wp-content/uploads/2010/01/2002962664.jpg" alt="empty() &amp; co, special values.jpg"></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>gettype()</tag>
        <tag>isempty()</tag>
        <tag>isset()</tag>
        <tag>is_null()</tag>
      </tags>
  </entry>
</search>
